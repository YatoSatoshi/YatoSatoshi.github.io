<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="Think different">
<meta property="og:type" content="website">
<meta property="og:title" content="SatoshiChin's blog">
<meta property="og:url" content="http://blog.SatoshiChin.com/index.html">
<meta property="og:site_name" content="SatoshiChin's blog">
<meta property="og:description" content="Think different">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SatoshiChin's blog">
<meta name="twitter:description" content="Think different">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> SatoshiChin's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">SatoshiChin's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Observing and thinking.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    
      
      
        
        
        
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/04/2016客户端现状相关思考/" itemprop="url">
                  2016客户端现状相关思考
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-03-04T17:01:33+08:00" content="2017-03-04">
              2017-03-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/04/2016客户端现状相关思考/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/04/2016客户端现状相关思考/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>2016年，或多或少都能感觉到客户端行业的萎缩，或者可能已经到了“悬崖边缘”，2017年会更加明显，个人感觉原因主要是以下几点。</p>
<h3 id="原因">原因</h3><h4 id="1-移动市场的成熟">1.移动市场的成熟</h4><p>体现在两方面，客户端技术本身上和客户端人才上：</p>
<p>技术上，如今移动基础设施实在是太成熟了，特别是在大公司了，以至与想搞个技术上大新闻太难了。</p>
<p>人才上，已经过饱和，虽然以前段时间的我面试他人的经历来看，高端人才还是很稀少，但是对于大部分(小)公司来说，这些人才已经很能满足业务需求了。</p>
<p>可以预见的将来，客户端从业人员，技术实力一般的，在找工作上会有较大困难，而对于技术实力较好的，在工作中较难搞出大突破。</p>
<h4 id="2-前端技术的冲击">2.前端技术的冲击</h4><p>主要是以ReactNative与Weex为代表的技术，技术特点都是上层使用JS等前端技术，通过JSCore桥接到下层的native层。</p>
<p>这类技术比起native的很显著优点是：</p>
<ul>
<li>动态性高</li>
<li>开发效率高</li>
<li>门槛低</li>
<li>一份代码，三端运行</li>
</ul>
<p>而这些优点，正好是大部分公司所关心的，既能快速快速更新业务，又能降低成本。</p>
<p>可以预见，除了性能要求与UI要求较为苛刻的业务，都会越来越倾向于选择这类技术。这个便会造成客户端相关的工作的减少。</p>
<p>此外，客户端越来越前端化，也是个趋势，特别是在UI布局上。</p>
<h4 id="3-行业热点转移">3.行业热点转移</h4><p>如果前几年，热点还是移动App本身的构建上的话，如今的热点可能已经是</p>
<ul>
<li>以VR、AR为代表的以图形学为基础相关新技术</li>
<li>直播等技术，这个可能快过了</li>
<li>机器学习，特别是深度学习</li>
</ul>
<p>而热点的转移，可能会影响到战略的转移，而战略的转移可能会影响资源的分配，而资源的分配势必会影响从业人员的个人发展(不管是技术还是业绩)。</p>
<h3 id="应对措施">应对措施</h3><p>对于在可能已经”在悬崖边上”的我们，应对方式是要<code>提升个人价值，降低可替换性</code>，而以下几点措施本质上其实也正是如此。</p>
<h4 id="1-多思考">1.多思考</h4><p>人与人之间可能最不可复制的东西就是个人的思考。</p>
<p>老板，老板的老板，高管们 同我们这些“社会底层员工”有个很大的区别就是，他们大部分时间都会进行深度思考，思考团队发展，思考业务未来，思考技术，思考战略方向等，而我们可能更多的只是着眼于手头的代码。</p>
<p>只知道这一步的人和知道下一步的人，存活者显而易见，</p>
<h4 id="2-提升技术深度">2.提升技术深度</h4><p>在自己的技术栈在业界还没“倒闭”的前提下，第二重要的事就是提升这个栈的深度。</p>
<p>有句话叫<code>深度决定成败</code>，对于技术上而言，深度更深的人，更容易做出NB的系统，更少的bug，更好的性能，可能更大的自信与影响力等。更现实而言更容易留下来或者通过面试。</p>
<p>另外一点，由于深度到了一定程度，这个深度也会成为其他栈的深度，从而使自己能更简单的完成第三点措施。举个例子，比如iOS你的深度到了汇编层、操作系统层，那么这些同时也都是安卓、后端栈的深度。</p>
<h4 id="3-提升技术广度">3.提升技术广度</h4><p>即跨栈。如果你是iOS栈，那么去学习下安卓，前端，后端。</p>
<p>会多个栈的优势太明显了，包含但不限于</p>
<ul>
<li>更广的技术视野</li>
<li>可替代性降低</li>
<li>团队中，能承担更大的责任与任务，得到更大的资源</li>
</ul>
<p>如果时间有限，只能选一个来跨，可能后端更合适点，因为 </p>
<ol>
<li>后端与客户端区别较大，提升会很大</li>
<li>后端更接近业务，能提升自己业务的深度 </li>
<li>后端在团队中的重要性相对更高</li>
</ol>
<p>此外，对于热点，比如机器学习，还是需要所有涉猎，还能抓一抓快忘了的数学相关基础，如果能在工作中加以尝试，就更酷了。</p>
<h3 id="最后">最后</h3><p>2017年，正式入职的第二年，希望自己能这几点上做的更好。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/02/objc_msgsend/" itemprop="url">
                  Objective-C Runtime汇编源码解析之objc_msgSend(arm64版本)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-11-02T02:43:33+08:00" content="2016-11-02">
              2016-11-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/02/objc_msgsend/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/02/objc_msgsend/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="前言">前言</h2><p>众所周知，Objective-C的方法调用是通过<code>objc_msgSend</code>来进行<code>动态的消息派发</code>，即objc_msgSend是Objective-C活的的灵魂。</p>
<p>然后该方法苹果是直接用汇编来实现的。下面，以开源的objc4-647版本，大致解析下在<code>arm64</code>上的汇编实现。</p>
<p>出于阅读效率考虑，我直接以注释的形式来逐行解析汇编内容。</p>
<h2 id="_objc_msgSend">_objc_msgSend</h2><p>_objc_msgSend消息派发最重要的入口，汇编实现如下，</p>
<p>ps：在最新版本iOS中调试中发现，相比于开源的objc，<strong>在调用过程中，x9和x16存放的内容相比老的开源版本，进行了互换</strong>：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>x16</th>
<th>x9</th>
</tr>
</thead>
<tbody>
<tr>
<td>最新iOS</td>
<td>class</td>
<td>SEL</td>
</tr>
<tr>
<td>objc4-647</td>
<td>SEL</td>
<td>class</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方法调用时，x0寄存器存放了self对象，x1存放了SEL */</span></span><br><span class="line"></span><br><span class="line">ENTRY _objc_msgSend</span><br><span class="line">	MESSENGER_START</span><br><span class="line"></span><br><span class="line">	cmp	x0, <span class="preprocessor">#<span class="number">0</span>			<span class="comment">// nil check and tagged pointer check</span></span></span><br><span class="line">	<span class="comment">/* 寄存器x0的内容与0作比较， 用来判断self是否是nil */</span></span><br><span class="line">	b.le	LNilOrTagged		<span class="comment">//  (MSB tagged pointer looks negative)</span></span><br><span class="line">	<span class="comment">/* 如果结果&lt;=0，即self是nil， 跳到LNilOrTagged*/</span></span><br><span class="line">	ldr	x13, [x0]		<span class="comment">// x13 = isa</span></span><br><span class="line">	<span class="comment">/* 以x0内容(指向类的isa)为地址，取该地址的内存内容放入x13寄存器，即 x13 = isa */</span></span><br><span class="line">	and	x9, x13, <span class="preprocessor">#ISA_MASK	<span class="comment">// x9 = class</span></span></span><br><span class="line">	<span class="comment">/* x9 = x13 按位与 ISA_MASK(isa的掩码) 即x9放入了class */</span>	</span><br><span class="line">LGetIsaDone:</span><br><span class="line">	CacheLookup NORMAL		<span class="comment">// calls imp or objc_msgSend_uncached</span></span><br><span class="line">	<span class="comment">/* 跳转CacheLookup 先查找缓存，失败则直接搜索方法列表 */</span></span><br><span class="line"></span><br><span class="line">LNilOrTagged:</span><br><span class="line">	b.eq	LReturnZero		<span class="comment">// nil check</span></span><br><span class="line">	<span class="comment">/* 如果x0是0，即self是nil，则跳转LReturnZero */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// tagged</span></span><br><span class="line">	<span class="comment">/* 否则是tagged pointer的情况 */</span></span><br><span class="line">	adrp	x10, _objc_debug_taggedpointer_classes@PAGE</span><br><span class="line">	<span class="comment">/* 加载tagged pointer类所在的内存页的地址到x10中 */</span></span><br><span class="line">	add	x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</span><br><span class="line">	<span class="comment">/* x10 = x10 + tagged pointer所在页面内的偏移量  即x10是tagged pointer的类地址 */</span></span><br><span class="line">	ubfx	x11, x0, <span class="preprocessor">#<span class="number">60</span>, #<span class="number">4</span></span></span><br><span class="line">	<span class="comment">/* 提取x0的高4位到x11低四位，并补0扩展成64位 即x11 = (x0 &amp; 0xf000000000000000) &gt;&gt; 60 */</span></span><br><span class="line">	ldr	x9, [x10, x11, LSL <span class="preprocessor">#<span class="number">3</span>]</span></span><br><span class="line">	<span class="comment">/* 以(x10 + (x11 &lt;&lt; 3))值为地址的取内容放入x9中，即x9放入了class */</span></span><br><span class="line">	b	LGetIsaDone</span><br><span class="line">	<span class="comment">/* 无返回的跳转LGetIsaDone */</span></span><br><span class="line">	</span><br><span class="line">LReturnZero:</span><br><span class="line">	<span class="comment">// x0 is already zero</span></span><br><span class="line">	<span class="comment">/* 将x1 d0 d1 d2 d3置为0 并返回 */</span></span><br><span class="line">	mov	x1, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line">	movi	d0, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line">	movi	d1, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line">	movi	d2, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line">	movi	d3, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line">	MESSENGER_END_NIL</span><br><span class="line">	ret</span><br><span class="line">	END_ENTRY _objc_msgSend</span><br><span class="line"></span><br><span class="line"><span class="comment">// ******************************** //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// objc_msgSendSuper的汇编实现</span></span><br><span class="line">	ENTRY _objc_msgSendSuper</span><br><span class="line">	MESSENGER_START</span><br><span class="line"></span><br><span class="line">	ldr	x9, [x0, <span class="preprocessor">#CLASS]	<span class="comment">// load class to search</span></span></span><br><span class="line">	<span class="comment">/* x9 = （x9 + #CLASS)为地址取内容， 即x9中放入isa的class */</span></span><br><span class="line">	ldr	x0, [x0, <span class="preprocessor">#RECEIVER]	<span class="comment">// load real receiver</span></span></span><br><span class="line">	<span class="comment">/* x0 = (x0 + #receiver)为地址内容，然后#RECEIVER=0所以这句并没有什么卵用，为以后设计的吧 */</span></span><br><span class="line">	CacheLookup NORMAL		<span class="comment">// calls imp or objc_msgSend_uncached</span></span><br><span class="line">	<span class="comment">/* 跳转CacheLookup */</span></span><br><span class="line"></span><br><span class="line">	END_ENTRY _objc_msgSendSuper</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc_msgSendSuper2的汇编实现 直接会去父类查找方法</span></span><br><span class="line">	ENTRY _objc_msgSendSuper2</span><br><span class="line">	MESSENGER_START</span><br><span class="line"></span><br><span class="line">	ldr	x9, [x0, <span class="preprocessor">#CLASS]</span></span><br><span class="line">	<span class="comment">/* (x0 + #CLASS)为地址取内存内容放入x9，即x9中放入class*/</span></span><br><span class="line">	ldr	x9, [x9, <span class="preprocessor">#SUPERCLASS]	<span class="comment">// load class to search</span></span></span><br><span class="line">	<span class="comment">/* 同上，x9放入SuperClass */</span></span><br><span class="line">	ldr	x0, [x0, <span class="preprocessor">#RECEIVER]	<span class="comment">// load real receiver</span></span></span><br><span class="line">	<span class="comment">/* 同上，x0中放入真正的reveiver */</span></span><br><span class="line">	CacheLookup NORMAL</span><br><span class="line">	<span class="comment">/* 跳转CacheLookup */</span></span><br><span class="line"></span><br><span class="line">	END_ENTRY _objc_msgSendSuper2</span><br></pre></td></tr></table></figure>
<p>由上可知<code>_objc_msgSend</code>这个汇编方法主要的<code>职责与流程</code>是：</p>
<ul>
<li>1.self的nil检查与处理</li>
<li>2.self的taggedpoint情况检查与处理</li>
<li>3.从self(x0)中取出class放入x9中，方便下一步的方法查找</li>
<li>4.跳转CacheLookup，进行方法的查找与调用</li>
</ul>
<h2 id="CacheLookup">CacheLookup</h2><p>CacheLookup主要功能是从class中查找到sel的imp，</p>
<p>进入该方法前，x9是class，x1是SEL</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class">.macro</span> CacheLookup</span><br><span class="line">	<span class="comment">// x1 = SEL, x9 = isa</span></span><br><span class="line">	ldp	x10, x11, [x9, <span class="hexcolor">#CAC</span>HE]	<span class="comment">// x10 = buckets, x11 = occupied|mask</span></span><br><span class="line">	<span class="comment">/* 以(x9 + #CACHE)为地址，取内存内容，取2个数据放入x10、x11, x10是buckets的地址，x11的低32位是mask（缓存上限+1），高32位是occupied(已占用的缓存) */</span></span><br><span class="line">	and	w12, w1, w11		<span class="comment">// x12 = _cmd &amp; mask</span></span><br><span class="line">	<span class="comment">/* x12的后32位 = x1的后32位_cmd &amp; x11的后32位mask</span><br><span class="line">	缓存的hash表的key是SEL，hash算法是SEL&amp;mask，冲突的解决方案是线性探查(n--)，这边是取该SEL缓存的最高的slot的值 */</span></span><br><span class="line">	add	x12, x10, x12, LSL #<span class="number">4</span>	<span class="comment">// x12 = buckets + ((_cmd &amp; mask)&lt;&lt;4)</span></span><br><span class="line">	<span class="comment">/* x12 = x10<span class="comment">/*buckets*/</span> + (x12<span class="comment">/*(_cmd &amp; mask)*/</span> &lt;&lt; 4), 定位到此SEL最高的bucket的内存地址,即每个bucket占用8*16位  */</span></span><br><span class="line">	</span><br><span class="line">	ldp	x16, x17, [x12]		<span class="comment">// &#123;x16, x17&#125; = *bucket</span></span><br><span class="line">	<span class="comment">/* 将x12内容作为指针对对应的内存，放入x16 与 x17中, 即x16存了bucket-&gt;sel, x17存了bucket-&gt;imp */</span></span><br><span class="line"><span class="number">1</span>:	cmp	x16, x1			<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">	<span class="comment">/* 比较x16 与 x1，即比较缓存的bucket的SEL与要调用的SEL(x1) */</span></span><br><span class="line">	<span class="tag">b</span><span class="class">.ne</span>	<span class="number">2</span>f			<span class="comment">//     scan more</span></span><br><span class="line">	<span class="comment">/* 不相等，跳转到2 继续扫描 */</span></span><br><span class="line">	CacheHit $<span class="number">0</span>			<span class="comment">// call or return imp</span></span><br><span class="line">	<span class="comment">/* 命中 则跳转CacheHit */</span></span><br><span class="line">	</span><br><span class="line"><span class="number">2</span>:	<span class="comment">// not hit: x12 = not-hit bucket</span></span><br><span class="line">	CheckMiss $<span class="number">0</span>			<span class="comment">// miss if bucket-&gt;cls == 0</span></span><br><span class="line">	<span class="comment">/* 如果ucket-&gt;cls == 0，则直接查找imp */</span></span><br><span class="line">	cmp	x12, x10		<span class="comment">// wrap if bucket == buckets</span></span><br><span class="line">	<span class="comment">/* 比较x12 与 x10  即当前的bucket与buckets，相等了则代表其他线程修改了缓存 */</span></span><br><span class="line">	<span class="tag">b</span><span class="class">.eq</span>	<span class="number">3</span>f</span><br><span class="line">	<span class="comment">/* 相等则到3的流程 */</span></span><br><span class="line">	ldp	x16, x17, [x12, #-<span class="number">16</span>]!	<span class="comment">// &#123;x16, x17&#125; = *--bucket</span></span><br><span class="line">	<span class="comment">/* &#123;x16, x17&#125; = (x12 - 16)的值为地址的内存内容，即加载上一个bucket */</span></span><br><span class="line">	<span class="tag">b</span>	<span class="number">1</span>b			<span class="comment">// loop</span></span><br><span class="line">	<span class="comment">/* 无返回的跳转到1 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:	<span class="comment">// wrap: x12 = first bucket, w11 = mask</span></span><br><span class="line">	add	x12, x12, w11, UXTW #<span class="number">4</span>	<span class="comment">// x12 = buckets+(mask&lt;&lt;4)</span></span><br><span class="line">	<span class="comment">/* x12 = x12 + (w11(x11的低32位) &lt;&lt; 4)  */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// clone scanning loop to crash instead of hang when cache is corrupt</span></span><br><span class="line"></span><br><span class="line">	ldp	x16, x17, [x12]		<span class="comment">// &#123;x16, x17&#125; = *bucket</span></span><br><span class="line"><span class="number">1</span>:	cmp	x16, x1			<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">	<span class="tag">b</span><span class="class">.ne</span>	<span class="number">2</span>f			<span class="comment">//     scan more</span></span><br><span class="line">	CacheHit $<span class="number">0</span>			<span class="comment">// call or return imp</span></span><br><span class="line">	</span><br><span class="line"><span class="number">2</span>:	<span class="comment">// not hit: x12 = not-hit bucket</span></span><br><span class="line">	CheckMiss $<span class="number">0</span>			<span class="comment">// miss if bucket-&gt;cls == 0</span></span><br><span class="line">	cmp	x12, x10		<span class="comment">// wrap if bucket == buckets</span></span><br><span class="line">	ldp	x16, x17, [x12, #-<span class="number">16</span>]!	<span class="comment">// &#123;x16, x17&#125; = *--bucket</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:	<span class="comment">// double wrap - busted</span></span><br><span class="line">					<span class="comment">// x0 = receiver</span></span><br><span class="line">					<span class="comment">// x1 = SEL</span></span><br><span class="line">	mov	x2, x9			<span class="comment">// x2 = isa</span></span><br><span class="line">	<span class="comment">/* x2 = x9， 即x2 = class */</span></span><br><span class="line"></span><br><span class="line"><span class="class">.if</span> $<span class="number">0</span> == GETIMP</span><br><span class="line">	mov	x0, #<span class="number">0</span></span><br><span class="line">	<span class="tag">b</span>	_cache_getImp_corrupt_cache_error</span><br><span class="line">	<span class="comment">/* 将x0置为0，无返回跳转_cache_getImp_corrupt_cache_error */</span></span><br><span class="line"><span class="class">.else</span></span><br><span class="line">	<span class="tag">b</span>	_objc_msgSend_corrupt_cache_error</span><br><span class="line">	<span class="comment">/* 无返回跳转_objc_msgSend_corrupt_cache_error */</span></span><br><span class="line"><span class="class">.endif</span></span><br><span class="line"></span><br><span class="line"><span class="class">.endmacro</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LGetImpHit:</span><br><span class="line">	<span class="comment">/* 在缓存中找到了imp，此时imp在x17 */</span></span><br><span class="line">	<span class="comment">// imp in x17</span></span><br><span class="line">	<span class="comment">// don't return msgSend_uncached</span></span><br><span class="line">	adrp	x16, __objc_msgSend_uncached_impcache@PAGE</span><br><span class="line">	add	x16, x16, __objc_msgSend_uncached_impcache@PAGEOFF</span><br><span class="line">	<span class="comment">/* 加载__objc_msgSend_uncached_impcache方法地址到x16 */</span></span><br><span class="line">	cmp	x16, x17</span><br><span class="line">	<span class="comment">/* 比较传进的imp与__objc_msgSend_uncached_impcache */</span></span><br><span class="line">	csel	x0, x17, xzr, ne	<span class="comment">// if imp!=uncached then imp else 0 </span></span><br><span class="line">	<span class="comment">/* x0 = (x16 != x17 ? x17 : xzr（0）), 即判断imp不是__objc_msgSend_uncached_impcache时，则返回imp，否则返回0(xzr寄存器作为源寄存器时，读出来是0) */</span></span><br><span class="line">	ret</span><br><span class="line">	<span class="comment">/* 返回 */</span></span><br><span class="line"></span><br><span class="line">LGetImpMiss:</span><br><span class="line">	mov	x0, #<span class="number">0</span></span><br><span class="line">	<span class="comment">/* x0放入0 */</span></span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	END_ENTRY _cache_getImp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class">.macro</span> CacheHit</span><br><span class="line">	MESSENGER_END_FAST</span><br><span class="line"><span class="class">.if</span> $<span class="number">0</span> == NORMAL</span><br><span class="line">	br	x17			<span class="comment">// call imp</span></span><br><span class="line">	<span class="comment">/* 如果Normal模式，有返回的跳转到x17的地址，即执行imp */</span></span><br><span class="line"><span class="class">.else</span></span><br><span class="line">	<span class="tag">b</span>	LGetImpHit</span><br><span class="line">	<span class="comment">/* 如果是GETIMP模式，无返回跳转LGetImpHit */</span></span><br><span class="line"><span class="class">.endif</span></span><br><span class="line"><span class="class">.endmacro</span></span><br><span class="line"></span><br><span class="line"><span class="class">.macro</span> CheckMiss</span><br><span class="line"><span class="comment">/* 进入时，x16存的当前bucket的SEL */</span></span><br><span class="line"><span class="class">.if</span> $<span class="number">0</span> == NORMAL			<span class="comment">// miss if bucket-&gt;cls == 0</span></span><br><span class="line">	cbz	x16, __objc_msgSend_uncached_impcache</span><br><span class="line">	<span class="comment">/* 如果x16为0则跳转__objc_msgSend_uncached_impcache来直接查找方法。即当前的slot中无缓存，说明该方法还没缓存过 */</span></span><br><span class="line"><span class="class">.else</span></span><br><span class="line">	cbz	x16, LGetImpMiss</span><br><span class="line">	<span class="comment">/* 如果x16为0则跳转LGetImpMiss */</span></span><br><span class="line"><span class="class">.endif</span></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
<p>由上可知，CacheLookup的主要职责与流程是：</p>
<ul>
<li>1:查找clss的cache的hash表，查找是否存在该IMP的缓存</li>
<li>2:如果查找到了缓存IMP，则直接调用</li>
<li>3:否则调用__objc_msgSend_uncached_impcache来直接查找方法</li>
</ul>
<h2 id="__objc_msgSend_uncached_impcache">__objc_msgSend_uncached_impcache</h2><p>当在缓存中没有找到imp，就会调用这个方法，并且在查找成功后会存入class的缓存中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached_impcache</span><br><span class="line"></span><br><span class="line"><span class="comment">// THIS IS NOT A CALLABLE C FUNCTION</span></span><br><span class="line"><span class="comment">// Out-of-band x9 is the class to search</span></span><br><span class="line"></span><br><span class="line">MESSENGER_START</span><br><span class="line"></span><br><span class="line"><span class="comment">// push frame</span></span><br><span class="line">stp	fp, lr, [sp, <span class="preprocessor">#-<span class="number">16</span>]!</span></span><br><span class="line"><span class="comment">/* sp -= 16, 保存当前fp, lr到sp的位置(占据sp-16， sp-8) */</span></span><br><span class="line">mov	fp, sp</span><br><span class="line"><span class="comment">/* 将sp放入fp中，即把当前的sp作为这个栈帧的frame pointer */</span></span><br><span class="line"></span><br><span class="line">MESSENGER_END_SLOW</span><br><span class="line"></span><br><span class="line"><span class="comment">// save parameter registers: x0..x8, q0..q7</span></span><br><span class="line">sub	sp, sp, <span class="preprocessor">#(<span class="number">10</span>*<span class="number">8</span> + <span class="number">8</span>*<span class="number">16</span>)</span></span><br><span class="line"><span class="comment">/* sp -= ((10*8 + 8*16)), 即此次方法调用需要208byte的空间，将栈低-208的空间留给变量 */</span></span><br><span class="line">stp	q0, q1, [sp, <span class="preprocessor">#(<span class="number">0</span>*<span class="number">16</span>)]</span></span><br><span class="line">stp	q2, q3, [sp, <span class="preprocessor">#(<span class="number">2</span>*<span class="number">16</span>)]</span></span><br><span class="line">stp	q4, q5, [sp, <span class="preprocessor">#(<span class="number">4</span>*<span class="number">16</span>)]</span></span><br><span class="line">stp	q6, q7, [sp, <span class="preprocessor">#(<span class="number">6</span>*<span class="number">16</span>)]</span></span><br><span class="line">stp	x0, x1, [sp, <span class="preprocessor">#(<span class="number">8</span>*<span class="number">16</span>+<span class="number">0</span>*<span class="number">8</span>)]</span></span><br><span class="line">stp	x2, x3, [sp, <span class="preprocessor">#(<span class="number">8</span>*<span class="number">16</span>+<span class="number">2</span>*<span class="number">8</span>)]</span></span><br><span class="line">stp	x4, x5, [sp, <span class="preprocessor">#(<span class="number">8</span>*<span class="number">16</span>+<span class="number">4</span>*<span class="number">8</span>)]</span></span><br><span class="line">stp	x6, x7, [sp, <span class="preprocessor">#(<span class="number">8</span>*<span class="number">16</span>+<span class="number">6</span>*<span class="number">8</span>)]</span></span><br><span class="line">str	x8,     [sp, <span class="preprocessor">#(<span class="number">8</span>*<span class="number">16</span>+<span class="number">8</span>*<span class="number">8</span>)]</span></span><br><span class="line"><span class="comment">/* 将上述寄存器内容保存在刚才的208byte的内存中，保存参数 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// receiver and selector already in x0 and x1</span></span><br><span class="line">mov	x2, x9</span><br><span class="line"><span class="comment">/* x9放入x2中 x9：class */</span></span><br><span class="line">bl	__class_lookupMethodAndLoadCache3</span><br><span class="line"><span class="comment">/* 跳转__class_lookupMethodAndLoadCache3 这是个c方法，用来直接查找方法(不会去缓存中寻找,因为上面已经找过了) 函数的返回值会放在x0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转回来，此时 imp 在 x0寄存器中</span></span><br><span class="line"></span><br><span class="line">mov	x17, x0</span><br><span class="line"><span class="comment">/* x0放入x17中，即x17存方法的imp */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// restore registers and return</span></span><br><span class="line">ldp	q0, q1, [sp, <span class="preprocessor">#(<span class="number">0</span>*<span class="number">16</span>)]</span></span><br><span class="line">ldp	q2, q3, [sp, <span class="preprocessor">#(<span class="number">2</span>*<span class="number">16</span>)]</span></span><br><span class="line">ldp	q4, q5, [sp, <span class="preprocessor">#(<span class="number">4</span>*<span class="number">16</span>)]</span></span><br><span class="line">ldp	q6, q7, [sp, <span class="preprocessor">#(<span class="number">6</span>*<span class="number">16</span>)]</span></span><br><span class="line">ldp	x0, x1, [sp, <span class="preprocessor">#(<span class="number">8</span>*<span class="number">16</span>+<span class="number">0</span>*<span class="number">8</span>)]</span></span><br><span class="line">ldp	x2, x3, [sp, <span class="preprocessor">#(<span class="number">8</span>*<span class="number">16</span>+<span class="number">2</span>*<span class="number">8</span>)]</span></span><br><span class="line">ldp	x4, x5, [sp, <span class="preprocessor">#(<span class="number">8</span>*<span class="number">16</span>+<span class="number">4</span>*<span class="number">8</span>)]</span></span><br><span class="line">ldp	x6, x7, [sp, <span class="preprocessor">#(<span class="number">8</span>*<span class="number">16</span>+<span class="number">6</span>*<span class="number">8</span>)]</span></span><br><span class="line">ldr	x8,     [sp, <span class="preprocessor">#(<span class="number">8</span>*<span class="number">16</span>+<span class="number">8</span>*<span class="number">8</span>)]</span></span><br><span class="line"><span class="comment">/* 将刚才保存的寄存器值从栈中恢复 */</span></span><br><span class="line">mov	sp, fp</span><br><span class="line"><span class="comment">/* 把当前stack pointer 设为 frame point的值 */</span></span><br><span class="line">ldp	fp, lr, [sp], <span class="preprocessor">#<span class="number">16</span></span></span><br><span class="line"><span class="comment">/* sp的内容为地址取内存放入&#123;fp,lr&#125;中，并sp+=16， 即还原到进栈前的状态 */</span></span><br><span class="line"></span><br><span class="line">br	x17</span><br><span class="line"><span class="comment">/* 有返回的跳转x17(imp) */</span></span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgSend_uncached_impcache</span><br></pre></td></tr></table></figure>
<p>由上可知，__objc_msgSend_uncached_impcache主要的职责与流程是：</p>
<ul>
<li>入栈，创建一个新的栈帧</li>
<li>调用__class_lookupMethodAndLoadCache3直接查找方法的imp</li>
<li>调用imp</li>
<li>出栈</li>
</ul>
<h2 id="_class_lookupMethodAndLoadCache3">_class_lookupMethodAndLoadCache3</h2><p>该方法功能是查找方法的imp并存入class的cache中,过程中会直接忽略缓存，因为在汇编代码的里面已经检查过了</p>
<p>不过具体逻辑不在这个方法中，而是调用了lookUpImpOrForward这个c方法，并传入flag告知该方法不需要initialize 不需要查找缓存</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line">IMP _class_lookupMethodAndLoadCache3(<span class="keyword">id</span> obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              <span class="literal">YES</span><span class="comment">/*initialize*/</span>, <span class="literal">NO</span><span class="comment">/*cache*/</span>, <span class="literal">YES</span><span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lookUpImpOrForward">lookUpImpOrForward</h2><p>该方法完成了标准的IMP查找，是用C++来实现的</p>
<p>cache=NO表示忽略不加锁的缓存查找，不过后面还是会查找缓存，一般initialize和cache=YES</p>
<p>有些条件下，会返回_objc_msgForward或_objc_msgForward_stret</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">_objc_msgForward_stret</span><br><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, <span class="keyword">id</span> inst, </span><br><span class="line">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span><br><span class="line">&#123;</span><br><span class="line">    Class curClass;</span><br><span class="line">    IMP imp = <span class="literal">nil</span>;</span><br><span class="line">    Method meth;</span><br><span class="line">    <span class="comment">// 标记了是否走过resolveInstance流程</span></span><br><span class="line">    <span class="keyword">bool</span> triedResolver = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    rwlock_assert_unlocked(&amp;runtimeLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">    	<span class="comment">// 先查找缓存， 用汇编实现</span></span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">    	<span class="comment">// 如果class还没有实现，实现类</span></span><br><span class="line">        rwlock_write(&amp;runtimeLock);</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        rwlock_unlock_write(&amp;runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">    <span class="comment">// 如果类还没有调用initialied方法，则调用initializer方法</span></span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁来保证method-lookup 和 cache-fill原子性</span></span><br><span class="line"> retry:</span><br><span class="line">    rwlock_read(&amp;runtimeLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ignore GC selectors</span></span><br><span class="line">    <span class="keyword">if</span> (ignoreSelector(sel)) &#123;</span><br><span class="line">        imp = _objc_ignored_method;</span><br><span class="line">        cache_fill(cls, sel, imp);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 尝试读缓存</span></span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    <span class="comment">// 找到则进入done的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 查找这个类的方法列表，不会查找父类</span></span><br><span class="line">    meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">    	<span class="comment">// 缓存这个img到cache中</span></span><br><span class="line">        log_and_fill_cache(cls, cls, meth-&gt;imp, sel);</span><br><span class="line">        imp = meth-&gt;imp;</span><br><span class="line">        <span class="comment">// 跳转done的逻辑</span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照继承链循环查找父类的缓存和方法列表</span></span><br><span class="line">    curClass = cls;</span><br><span class="line">    <span class="keyword">while</span> ((curClass = curClass-&gt;superclass)) &#123;</span><br><span class="line">        <span class="comment">// 查找父类缓存</span></span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                <span class="comment">// 如果不是_objc_msgForward_impcache，则缓存并跳转done</span></span><br><span class="line">                log_and_fill_cache(cls, curClass, imp, sel);</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是forward，则直接跳出循环，先不处理，为了先来一次消息派发的resolver那个流程</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找父类的方法列表，找到则缓存并跳转done</span></span><br><span class="line">        meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, curClass, meth-&gt;imp, sel);</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 至此，所有父类都没有该方法，先尝试一次resolver的流程</span></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        rwlock_unlock_read(&amp;runtimeLock);</span><br><span class="line">        <span class="comment">// 调用_class_resolveMethod执行reslover流程</span></span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        triedResolver = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">// 直接进try流程，因为没有持有锁，有可能relover的过程中已经被其他线程改了</span></span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找不到方法，并且resolver也没解决，则使用消息转发</span></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    <span class="comment">// 缓存sel的imp为转发</span></span><br><span class="line">    cache_fill(cls, sel, imp);</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line"> 	<span class="comment">// 返回imp</span></span><br><span class="line">    rwlock_unlock_read(&amp;runtimeLock);</span><br><span class="line">    </span><br><span class="line">    assert(!(ignoreSelector(sel)  &amp;&amp;  imp != (IMP)&amp;_objc_ignored_method));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上lookUpImpOrForward额职责与流程是：</p>
<ul>
<li>1：如果cache=YES，先不加锁的查找一次缓存</li>
<li>2：查找缓存，找到进入7，否则往下</li>
<li>3：查找这个类的方法列表，找到缓存并进入7，否则往下</li>
<li>4：查找父类的缓存与方法列表，没找到则查找更上一级的父类，重复此过程，直到没有父类，找到则(缓存)并进入7，否则往下</li>
<li>5：如果没尝试过resolver，调用_class_resolveMethod，进入resolver流程，也就是调用类的resolveClassMethod或resolveInstanceMethod，然后跳到2，否则往下</li>
<li>6：end 缓存并返回_objc_msgForward_impcache</li>
<li>7：end 返回找到的imp</li>
</ul>
<h2 id="__objc_msgForward_impcache">__objc_msgForward_impcache</h2><p>然后，看一下上面出现的objc_msgForward_impcache的实现，这方法是由汇编代码实现</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="label">STATIC_ENTRY</span> __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"><span class="label">MESSENGER_START</span></span><br><span class="line"><span class="keyword">nop</span><br><span class="line"></span><span class="label">MESSENGER_END_SLOW</span></span><br><span class="line"></span><br><span class="line">// No <span class="keyword">stret </span>specialization.</span><br><span class="line"><span class="keyword">b	</span>__objc_msgForward</span><br><span class="line"><span class="comment">/* 跳转__objc_msgForward */</span></span><br><span class="line"></span><br><span class="line"><span class="label">END_ENTRY</span> __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="label">ENTRY</span> __objc_msgForward</span><br><span class="line"></span><br><span class="line"><span class="keyword">adrp	</span>x17, __objc_forward_handler<span class="comment">@PAGE</span></span><br><span class="line"><span class="comment">/* 将__objc_forward_handler做在的内存页地址放入x17中  */</span></span><br><span class="line"><span class="keyword">ldr	</span>x17, [x17, __objc_forward_handler<span class="comment">@PAGEOFF]</span></span><br><span class="line"><span class="comment">/* x17 = __objc_forward_handler所在内存页中偏移量 + x17，即x17</span><br><span class="line">是__objc_forward_handler这个方法 */</span></span><br><span class="line"><span class="keyword">br	</span>x17</span><br><span class="line"><span class="comment">/* 有返回的跳转__objc_forward_handler */</span></span><br><span class="line"></span><br><span class="line"><span class="label">END_ENTRY</span> __objc_msgForward</span><br></pre></td></tr></table></figure>
<p>可知，<strong>objc_msgForward_impcache 调用了 </strong>objc_msgForward 调用了__objc_forward_handler，</p>
<p>而__objc_forward_handler默认实现objc_defaultForwardHandler没做任何事情，只是报错和crash</p>
<p>而我们平时forward的具体实现是在<code>Core Foundation</code>这一层中通过<code>objc_setForwardHandler</code>来<code>注入</code>实现的。</p>
<p>```</p>
<h2 id="总结">总结</h2><p>经过源码分析，可以得出整个过程是：<br><img src="/uploads/msgsendFlowChart.png" alt="flowchart"></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/04/Runloop/" itemprop="url">
                  CoreFundation源码解析之RunLoop
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-07-04T01:05:33+08:00" content="2016-07-04">
              2016-07-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/04/Runloop/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/04/Runloop/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="CoreFundation源码解析之RunLoop">CoreFundation源码解析之RunLoop</h2><hr>
<h3 id="什么是RunLoop">什么是RunLoop</h3><p>RunLoop就是组合在线程上的一部分基础设施，用来处理事件的循环。</p>
<p>我觉得runloop比起通常的do-while循环来说，提供的最重要的能力是使线程能在<code>需要工作</code>的时候<code>工作</code>，而<code>不需要工作</code>的<code>睡眠</code>（操作系统上就是进入wating的队列，从而让出cpu资源(时间片)），增加硬件的使用率。</p>
<p>Runloop主要是定义在CoreFundation这一层，暴露一系列C的APi，此外还有个NSRunloop的OC类用来包装成OC的对象。</p>
<p><strong>接下去主要解析的是Runloop的源码上的实现，解析内容大部分直接注释到了源码里，方便观看，ps:中文注释都是我加的，而不是苹果注释的 - -</strong></p>
<h3 id="数据结构定义">数据结构定义</h3><h4 id="CFRunloop">CFRunloop</h4><p>CFRunloop的结构体的定义如下，详细信息注释在代码中</p>
<pre><code>    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_MUTABLE_TYPE</span>(<span class="keyword">id</span>) __<span class="built_in">CFRunLoop</span> *     <span class="built_in">CFRunLoopRef</span>;
<span class="keyword">struct</span> __<span class="built_in">CFRunLoop</span> {
    <span class="built_in">CFRuntimeBase</span> _base;  <span class="comment">// 存储运行时相关数据，类似OC class中的ISA</span>
    pthread_mutex_t _lock; <span class="comment">// 互斥锁，用来在接触mode时加锁</span>
    __<span class="built_in">CFPort</span> _wakeUpPort;    <span class="comment">// CFPort是对mach_port的包装，Api中的CFRunLoopWakeUp方法就是通过向这个端口发消息来唤醒runloop的</span>
    Boolean _unused;
    <span class="keyword">volatile</span> _per_run_data *_perRunData; <span class="comment">// runloop的的一些控制数据，比如能否被唤醒等，每一次loop中都会新建一个</span>
    pthread_t _pthread; <span class="comment">// 和runloop绑定的线程</span>
    <span class="built_in">CFMutableSetRef</span> _commonModes; <span class="comment">// common mode包含的mode的name</span>
    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// common mode中的所有timer、source、observer</span>
    <span class="built_in">CFRunLoopModeRef</span> _currentMode; <span class="comment">// 当前mode</span>
    <span class="built_in">CFMutableSetRef</span> _modes; <span class="comment">// runloop的所有mode</span>
    <span class="comment">// 通过CFRunLoopPerformBlock加入到runloop下的item链表</span>
    <span class="keyword">struct</span> _block_item *_blocks_head; <span class="comment">// block_item链表的头</span>
    <span class="keyword">struct</span> _block_item *_blocks_tail; <span class="comment">// block_item链表的尾</span>
    <span class="built_in">CFAbsoluteTime</span> _runTime; <span class="comment">// 运行的时间</span>
    <span class="built_in">CFAbsoluteTime</span> _sleepTime; <span class="comment">// 睡眠的时间</span>
    <span class="built_in">CFTypeRef</span> _counterpart; 
};
</code></pre><h3 id="Runloop_Mode">Runloop Mode</h3><p>Runloop Mode = Sources + Timers + Observers + others</p>
<p>也就是包含了一些列事件的来源、定时器、观察者和其他的一些数据。</p>
<p>Mode间通过name来区分。Runloop中必须要有Mode，不然不会运行，此外每次loop只能运行在一个mode下，等等可以runloop run的源码中验证。</p>
<p>Core Fundation和Cocoa内置了很多Mode</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Name</th>
<th>Des</th>
</tr>
</thead>
<tbody>
<tr>
<td>Default</td>
<td>NSDefaultRunLoopMode (Cocoa) kCFRunLoopDefaultMode (Core Foundation)</td>
<td>大部分操作都在这个mode下</td>
</tr>
<tr>
<td>Connection</td>
<td>NSConnectionReplyMode (Cocoa)</td>
<td>NSConnection通过这个Mode来监听远端的相应</td>
</tr>
<tr>
<td>Modal</td>
<td>NSModalPanelRunLoopMode (Cocoa)</td>
<td></td>
</tr>
<tr>
<td>Event tracking</td>
<td>NSEventTrackingRunLoopMode (Cocoa)</td>
<td>跟踪滚动等UI相关事件的模式</td>
</tr>
<tr>
<td>Common modes</td>
<td>NSRunLoopCommonModes (Cocoa) kCFRunLoopCommonModes (Core Foundation)</td>
<td>包含了很多经常使用的Mode的结合的Mode。Cocoa中的该模式默认包含了Default、Modal、Event tracking，可以通过CFRunLoopAddCommonMode自由的添加其他mode</td>
</tr>
</tbody>
</table>
<h5 id="Runloop_Mode的数据结构">Runloop Mode的数据结构</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base; <span class="comment">// 运行时相关数据，isa</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;	<span class="comment">// 互斥锁</span></span><br><span class="line">    CFStringRef _name; <span class="comment">// mode的名字</span></span><br><span class="line">    Boolean _stopped; <span class="comment">// mode是否停止</span></span><br><span class="line">    <span class="keyword">char</span> _padding[<span class="number">3</span>]; </span><br><span class="line">    CFMutableSetRef _sources0; <span class="comment">// source0 集合内的类型是CFRunLoopSourceContext</span></span><br><span class="line">    CFMutableSetRef _sources1; <span class="comment">// source1 集合内的类型是CFRunLoopSourceContext1</span></span><br><span class="line">    <span class="comment">// source1和0最大的区别是source1里有mach_port</span></span><br><span class="line">    CFMutableArrayRef _observers; <span class="comment">// mode上的观察者s</span></span><br><span class="line">    CFMutableArrayRef _timers;  <span class="comment">// mode上的定时器s</span></span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;<span class="comment">// machport到soure0的映射</span></span><br><span class="line">    __CFPortSet _portSet; <span class="comment">// mode上的portSet端口，包含很多member，并有用接收msg的权限</span></span><br><span class="line">    CFIndex _observerMask; /</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    <span class="keyword">dispatch_source_t</span> _timerSource;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> _queue;</span><br><span class="line">    Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> _timerPort; <span class="comment">// 定时器相关的mach端口，上面的timers全靠这个port才会被fire</span></span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerSoftDeadline; <span class="comment">/* TSR */</span> <span class="comment">// 所有timer中 fire时间最近的timer的TSR</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerHardDeadline; <span class="comment">/* TSR */</span> <span class="comment">// 所有timer中 fire时间加容忍度时间最近的timer的TSR</span></span><br></pre></td></tr></table></figure>
<h4 id="Runloop_Source">Runloop Source</h4><p>Source代表了事件的来源，可以是基于port的，也可以是自定义的（不过得自己在合适的实际手动触发(signaling)）, 也可是是Perform Selector。</p>
<h4 id="Runloop_Source数据结构">Runloop Source数据结构</h4><pre><code><span class="class"><span class="keyword">struct</span> <span class="title">__CFRunLoopSource</span> {</span>
    <span class="constant">CFRuntimeBase</span> _base;
    uint32_t _bits;
    pthread_mutex_t _lock;
    <span class="constant">CFIndex</span> _order;            <span class="regexp">/* immutable */</span>
    <span class="constant">CFMutableBagRef</span> _runLoops;
    <span class="class"><span class="keyword">union</span> {</span>
    <span class="constant">CFRunLoopSourceContext</span> version0; <span class="regexp">//source</span>0 无port
    <span class="constant">CFRunLoopSourceContext1</span> version1; <span class="regexp">//</span> source1 有port
    } _context;
};
</code></pre><p>__CFRunLoopSource本身没什么好注释的，主要的内容在SourceContext中</p>
<h4 id="CFRunLoopSourceContext">CFRunLoopSourceContext</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span>	version;</span><br><span class="line">    <span class="keyword">void</span> *	info;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="built_in">CFStringRef</span>	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    Boolean	(*equal)(<span class="keyword">const</span> <span class="keyword">void</span> *info1, <span class="keyword">const</span> <span class="keyword">void</span> *info2);</span><br><span class="line">    <span class="built_in">CFHashCode</span>	(*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span>	(*schedule)(<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line">    <span class="keyword">void</span>	(*cancel)(<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line">    <span class="keyword">void</span>	(*perform)(<span class="keyword">void</span> *info); <span class="comment">// signal后的事件函数</span></span><br><span class="line">&#125; <span class="built_in">CFRunLoopSourceContext</span>;</span><br></pre></td></tr></table></figure>
<h4 id="CFRunLoopSourceContext1">CFRunLoopSourceContext1</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span>	version;</span><br><span class="line">    <span class="keyword">void</span> *	info;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="built_in">CFStringRef</span>	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    Boolean	(*equal)(<span class="keyword">const</span> <span class="keyword">void</span> *info1, <span class="keyword">const</span> <span class="keyword">void</span> *info2);</span><br><span class="line">    <span class="built_in">CFHashCode</span>	(*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sourcce1 绑定了mach端口, 这是和source0最大的区别</span></span><br><span class="line">    mach_port_t	(*getPort)(<span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span> *	(*perform)(<span class="keyword">void</span> *msg, <span class="built_in">CFIndex</span> size, <span class="built_in">CFAllocatorRef</span> allocator, <span class="keyword">void</span> *info);</span><br><span class="line">&#125; <span class="built_in">CFRunLoopSourceContext1</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到Source0和Source1最大的区别是Source1拥有mach port，可以自己触发。</p>
<h4 id="Runloop_Timer">Runloop Timer</h4><p>Runloop设计的比较好的一是加到mode中的所有timer，不是说自己开个port去实现，而是通过Mode中的<code>_timerPort</code>，去触发。</p>
<p>addTimer的时候，CoreFundation会算遍历timers，拿到最近的fire时间，然后通过_timerPort去实现该fire的定时，fire之后会继续计算设置成下一个。</p>
<h5 id="__CFRunLoopTimer_&amp;_CFRunLoopTimerContext">__CFRunLoopTimer &amp; CFRunLoopTimerContext</h5><p>timer的相关结构没什么好说，比较简单</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span>	version;</span><br><span class="line">    <span class="keyword">void</span> *	info;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="built_in">CFStringRef</span>	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">&#125; <span class="built_in">CFRunLoopTimerContext</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoopTimer</span> &#123;</span><br><span class="line">    <span class="built_in">CFRuntimeBase</span> _base;</span><br><span class="line">    uint16_t _bits;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> _runLoop;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _rlModes;</span><br><span class="line">    <span class="built_in">CFAbsoluteTime</span> _nextFireDate;</span><br><span class="line">    <span class="built_in">CFTimeInterval</span> _interval;		<span class="comment">/* immutable */</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> _tolerance;     <span class="comment">//容忍度     /* mutable */</span></span><br><span class="line">    uint64_t _fireTSR;			<span class="comment">/* TSR units */</span></span><br><span class="line">    <span class="built_in">CFIndex</span> _order;			<span class="comment">/* immutable */</span></span><br><span class="line">    <span class="built_in">CFRunLoopTimerCallBack</span> _callout;	<span class="comment">// 回调</span></span><br><span class="line">    <span class="built_in">CFRunLoopTimerContext</span> _context;	<span class="comment">/* immutable, except invalidation */</span></span><br></pre></td></tr></table></figure>
<h4 id="Runloop_observer">Runloop observer</h4><p>Runloop的观察着，顾名思义，runloop的生命周期中的一些切面会被回调回调方法。</p>
<p>看了下代码，回调也是执行在当前Runloop的线程上，所以我觉得如果是在观察主线程的Runloop，最好不要放一些太重的活进去，或者分发到其他线程去。</p>
<h5 id="__CFRunLoopObserver">__CFRunLoopObserver</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoopObserver</span> &#123;</span><br><span class="line">    <span class="built_in">CFRuntimeBase</span> _base; <span class="comment">// 类似OC的isa，不过还存储了observer的isfire，isValid等状态信息</span></span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> _runLoop;</span><br><span class="line">    <span class="built_in">CFIndex</span> _rlCount;</span><br><span class="line">    <span class="built_in">CFOptionFlags</span> _activities;		<span class="comment">// 标识了观测哪些事件</span></span><br><span class="line">    <span class="built_in">CFIndex</span> _order;			<span class="comment">/* immutable */</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverCallBack</span> _callout;	<span class="comment">// 回调</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> _context;	<span class="comment">// 上下文</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span>	version;</span><br><span class="line">    <span class="keyword">void</span> *	info; <span class="comment">// 创建时，传进来的info，回调时会带上</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="built_in">CFStringRef</span>	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">&#125; <span class="built_in">CFRunLoopObserverContext</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Runloop运行函数流程">Runloop运行函数流程</h3><p>Runloop的默认入口是CFRunLoopRun()，此时runloop的mode是DefaultMode。此外还有一个入口是CFRunLoopRunInMode()，可以指定以特定的mode运行。</p>
<p>整个链路是CFRunLoopRun() -&gt; CFRunLoopRunSpecific() -&gt;__CFRunLoopRun(),一个一个来看。</p>
<h3 id="CFRunLoopRun()">CFRunLoopRun()</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="type">CFRunLoopRun</span>(<span class="type">void</span>) &#123;	/* <span class="type">DOES</span> <span class="type">CALLOUT</span> */</span><br><span class="line">    int32_t <span class="literal">result</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="literal">result</span> = <span class="type">CFRunLoopRunSpecific</span>(<span class="type">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1</span>.<span class="number">0</span>e10, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">CHECK_FOR_FORK</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != <span class="literal">result</span> &amp;&amp; kCFRunLoopRunFinished != <span class="literal">result</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到CFRunLoopRun方法就是一个do-while循环，只要运行结果不是stop和finish，就会进入下个循环。逻辑全在<code>CFRunLoopRunSpecific</code>这个方法中.</p>
<h4 id="CFRunLoopRunSpecific()">CFRunLoopRunSpecific()</h4><p>源代码如下，基本上我都加上了注释</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">SInt32 <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="comment">// 如果runloop正在dealloc，则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (__<span class="built_in">CFRunLoopIsDeallocating</span>(rl)) <span class="keyword">return</span> k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    __<span class="built_in">CFRunLoopLock</span>(rl);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得要运行的Mode， 没有则新建新一个Mode，并初始化</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __<span class="built_in">CFRunLoopFindMode</span>(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// __CFRunLoopModeIsEmpty会去检查mode，如果有mode，并且mode至少有timer、observer、source中的任意一个，则为非空，否则退出当次loop</span></span><br><span class="line">    <span class="comment">// 如果当前runloop是主线程上的，条件会简单点，只要存在这个mode name就行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode || __<span class="built_in">CFRunLoopModeIsEmpty</span>(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">	Boolean did = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (currentMode) __<span class="built_in">CFRunLoopModeUnlock</span>(currentMode);</span><br><span class="line">	__<span class="built_in">CFRunLoopUnlock</span>(rl);</span><br><span class="line">	<span class="keyword">return</span> did ? k<span class="built_in">CFRunLoopRunHandledSource</span> : k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成一份新的PerRunData，初始化后，传给runloop</span></span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __<span class="built_in">CFRunLoopPushPerRunData</span>(rl);</span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> previousMode = rl-&gt;_currentMode;</span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    int32_t result = k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知观察者即将进入runloop：kCFRunLoopEntry</span></span><br><span class="line">	<span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopEntry</span> ) __<span class="built_in">CFRunLoopDoObservers</span>(rl, currentMode, k<span class="built_in">CFRunLoopEntry</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调用__CFRunLoopRun，运行runloop，最繁杂逻辑都在里面</span></span><br><span class="line">	result = __<span class="built_in">CFRunLoopRun</span>(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 通知观察者即将退出runloop</span></span><br><span class="line">	<span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopExit</span> ) 		__<span class="built_in">CFRunLoopDoObservers</span>(rl, currentMode, k<span class="built_in">CFRunLoopExit</span>);</span><br><span class="line"></span><br><span class="line">    __<span class="built_in">CFRunLoopModeUnlock</span>(currentMode);</span><br><span class="line">      <span class="comment">// 将Runloop的PerRunData赋值为之前的值，也就是还原成进入之前的状态</span></span><br><span class="line">        __<span class="built_in">CFRunLoopPopPerRunData</span>(rl, previousPerRun);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 当次loop退出后会把mode还原为上一次的mode</span></span><br><span class="line">	rl-&gt;_currentMode = previousMode;</span><br><span class="line">    __<span class="built_in">CFRunLoopUnlock</span>(rl);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最大的逻辑还不在这个方法中，主要做了一些初始化以及上下文的切换，以及进入和退出的通知，Loop的主要逻辑是直接调用了<strong>CFRunLoopRun这个方法，那么接着看 </strong>CFRunLoopRun的实现。</p>
<h4 id="__CFRunLoopRun()">__CFRunLoopRun()</h4><p>为了方便阅读，我把一些只在macOS或者Window上的逻辑都去掉了，并尽可能详细的注释与讲解了每一行代码。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int32_t __<span class="built_in">CFRunLoopRun</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopModeRef</span> rlm, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle, <span class="built_in">CFRunLoopModeRef</span> previousMode) &#123;</span><br><span class="line">	<span class="comment">// 记录当前时钟”嘀嗒”数，可看成该次loop的开始时间</span></span><br><span class="line">    uint64_t startTSR = mach_absolute_time();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *** runloop 是否已结束检测，是则直接退出 --- *** */</span></span><br><span class="line">    <span class="keyword">if</span> (__<span class="built_in">CFRunLoopIsStopped</span>(rl)) &#123;</span><br><span class="line">    <span class="comment">// ↑检查了runloop的_perRunData-&gt;stopped是否为非0</span></span><br><span class="line">        <span class="comment">// runloop 是stop，则将_perRunData-&gt;stopped置为0，并退出当次runloop</span></span><br><span class="line">        __<span class="built_in">CFRunLoopUnsetStopped</span>(rl);</span><br><span class="line">        <span class="keyword">return</span> k<span class="built_in">CFRunLoopRunStopped</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">        <span class="comment">// runloop mode是stop</span></span><br><span class="line">        rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> k<span class="built_in">CFRunLoopRunStopped</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/* *** 这块是主线程下获取dispatchPort的逻辑，如果当前线程不是主线程，就没有什么意义*** */</span></span><br><span class="line">    <span class="comment">// __HAS_DISPATCH__这个宏看代码是 如果部署在Swift的运行时下(DEPLOYMENT_RUNTIME_SWIFT),则是0，否则是1</span></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">    <span class="comment">// 主线程的dispatchPort端口</span></span><br><span class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</span><br><span class="line">    <span class="comment">// pthread_main_np返回当前是否是main thread </span></span><br><span class="line">    <span class="comment">// HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY = 0</span></span><br><span class="line">    <span class="comment">// 总之条件是 当前线程是mainQ才行</span></span><br><span class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVO<span class="built_in">CATION_ONLY</span> &amp;&amp; <span class="literal">NULL</span> == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVO<span class="built_in">CATION_ONLY</span> &amp;&amp; <span class="number">0</span> == _<span class="built_in">CFGetTSD</span>(__<span class="built_in">CFTSDKeyIsInGCDMainQ</span>)));</span><br><span class="line">    <span class="comment">// 如果当前是mainQ，且满足一定条件，获取主线程中的_dispatch_get_main_queue_port_4CF端口</span></span><br><span class="line">    <span class="keyword">if</span> (libdispatchQSafe &amp;&amp; (<span class="built_in">CFRunLoopGetMain</span>() == rl) &amp;&amp; <span class="built_in">CFSetContainsValue</span>(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="comment">/* *** 设置当次loop的超时定时器 *** */</span></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">	<span class="comment">// 定义gcd的定时器</span></span><br><span class="line">    dispatch_source_t timeout_timer = <span class="literal">NULL</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">    <span class="comment">// 时间片检查</span></span><br><span class="line">    <span class="keyword">struct</span> __timeout_context *timeout_context = (<span class="keyword">struct</span> __timeout_context *)malloc(<span class="keyword">sizeof</span>(*timeout_context));</span><br><span class="line">    <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>) &#123; <span class="comment">// instant timeout</span></span><br><span class="line">        <span class="comment">// 剩余时间耗尽</span></span><br><span class="line">        seconds = <span class="number">0.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR = <span class="number">0</span>ULL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">        <span class="comment">// 还有剩余时间</span></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> queue = pthread_main_np() ? __<span class="built_in">CFDispatchQueueGetGenericMatchingMain</span>() : __<span class="built_in">CFDispatchQueueGetGenericBackground</span>();</span><br><span class="line">	timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">        dispatch_retain(timeout_timer);</span><br><span class="line">	timeout_context-&gt;ds = timeout_timer;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">	<span class="comment">// 计算到期的时间点，并赋值</span></span><br><span class="line">	timeout_context-&gt;rl = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFRetain</span>(rl);</span><br><span class="line">	timeout_context-&gt;termTSR = startTSR + __<span class="built_in">CFTimeIntervalToTSR</span>(seconds);</span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">	dispatch_set_context(timeout_timer, timeout_context); <span class="comment">// source gets ownership of context</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 设置timer超时的handler 会把termTSR设为0，并唤醒runloop</span></span><br><span class="line">	dispatch_source_set_event_handler_f(timeout_timer, __<span class="built_in">CFRunLoopTimeout</span>);</span><br><span class="line">    dispatch_source_set_cancel_handler_f(timeout_timer, __<span class="built_in">CFRunLoopTimeoutCancel</span>);</span><br><span class="line">    uint64_t ns_at = (uint64_t)((__<span class="built_in">CFTSRToTimeInterval</span>(startTSR) + seconds) * <span class="number">1000000000</span>ULL);</span><br><span class="line">    dispatch_source_set_timer(timeout_timer, dispatch_time(<span class="number">1</span>, ns_at), DISPATCH_TIME_FOREVER, <span class="number">1000</span>ULL);</span><br><span class="line">    <span class="comment">// 启动定时器</span></span><br><span class="line">    dispatch_resume(timeout_timer);</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// infinite timeout</span></span><br><span class="line">        <span class="comment">// 无限的剩余时间</span></span><br><span class="line">        seconds = <span class="number">9999999999.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR = <span class="built_in">UINT64_MAX</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    Boolean didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">    int32_t retVal = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</span><br><span class="line">        voucher_t voucherCopy = <span class="literal">NULL</span>;</span><br><span class="line">        uint8_t msg_buffer[<span class="number">3</span> * <span class="number">1024</span>];</span><br><span class="line">        mach_msg_header_t *msg = <span class="literal">NULL</span>;</span><br><span class="line">        mach_port_t livePort = MACH_PORT_NULL;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 获得mode上的portset端口， _portSet也是个mach_port_t类型，不过该端口拥有接收消息的功能，能接收自己的menber ports上的消息【1】此处等等会细讲</span></span><br><span class="line">		__<span class="built_in">CFPortSet</span> waitSet = rlm-&gt;_portSet;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获得runloop的perRunData， 设置ignoreWakeUps为0：无视唤醒</span></span><br><span class="line">        __<span class="built_in">CFRunLoopUnsetIgnoreWakeUps</span>(rl);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">/* *** 通知 *** */</span></span><br><span class="line">        <span class="comment">// 通知观察者runloop将处理timer</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopBeforeTimers</span>) __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopBeforeTimers</span>);</span><br><span class="line">        <span class="comment">// 通知观察者runloop将处理Source</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopBeforeSources</span>) __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopBeforeSources</span>);</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">/* *** 触发所有通过CFRunloopPerformBlock方法加入到当前runloop的该mode的所有block *** */</span></span><br><span class="line">        <span class="comment">// 【2】这块等等还会提一下</span></span><br><span class="line">        __<span class="built_in">CFRunLoopDoBlocks</span>(rl, rlm);</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *** 处理Source0上的所有source *** */</span></span><br><span class="line">		<span class="comment">// 通过__CFRunLoopSourceIsSignaled方法获取到Source上的signal标记，只有 signal非0</span></span><br><span class="line">        <span class="comment">// 才会调用所有在该mode上的source0的source的perform函数</span></span><br><span class="line">        	<span class="comment">// 返回值代表了至少有1个source被处理了</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __<span class="built_in">CFRunLoopDoSources0</span>(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            <span class="comment">// source0有处理了触发的source 则重新处理的block</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoBlocks</span>(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记 代表了处理完了source0或者时间没了</span></span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0</span>ULL == timeout_context-&gt;termTSR);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *** 只有在主线程上才有的逻辑，处理dispatchPort上的msg *** */</span></span><br><span class="line"><span class="comment">// 因为非主线，diaptchport是个null</span></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">            <span class="comment">// 如果有主线程的dispatchPort端口上的消息，则处理</span></span><br><span class="line">            		<span class="comment">// 这端口基本就是和GCD中sync/async到主线程相关的端口了</span></span><br><span class="line">            <span class="keyword">if</span> (__<span class="built_in">CFRunLoopServiceMachPort</span>(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            	<span class="comment">// 调到下方的处理msg的逻辑里</span></span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">       didDispatchPortLastTime = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *** 通知 *** */</span></span><br><span class="line">    <span class="comment">// 通知观察者runloop即将睡眠 kCFRunLoopBeforeWaiting</span></span><br><span class="line">	<span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopBeforeWaiting</span>)) __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopBeforeWaiting</span>);</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line">	</span><br><span class="line">      <span class="comment">// runloop标记为睡眠， 通过改变runloop的cfruntimebase的_cfinfo标记</span></span><br><span class="line">	__<span class="built_in">CFRunLoopSetSleeping</span>(rl);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *** 主线程才有用 *** */</span></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">        <span class="comment">// 调用mach_port_insert_member将dispatchport作为waitport的menmber</span></span><br><span class="line">        <span class="comment">// 这样接下去可以通过waitport来接收disptchport的消息以及其他menber的消息</span></span><br><span class="line">        __<span class="built_in">CFPortSetInsert</span>(dispatchPort, waitSet);</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">	__<span class="built_in">CFRunLoopModeUnlock</span>(rlm);</span><br><span class="line">	__<span class="built_in">CFRunLoopUnlock</span>(rl);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 记录睡眠开始的时间</span></span><br><span class="line">        <span class="built_in">CFAbsoluteTime</span> sleepStart = poll ? <span class="number">0.0</span> : <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// timer处理</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k<span class="built_in">CFUseCollectableAllocator</span>) &#123;</span><br><span class="line">            memset(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</span><br><span class="line">        &#125;</span><br><span class="line">        msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">/* *** 进入睡眠，并监听mach端口 *** */</span> </span><br><span class="line">        <span class="comment">// 睡眠，并监听与处理waitport的上的消息，也就是监听所有source1的端口以及之前加上的dispatchport,以及wakeupPort、timerPort</span></span><br><span class="line">        <span class="comment">// 内部调用了mach_msg来接收消息，这块等等还会讲一下【3】</span></span><br><span class="line">        __<span class="built_in">CFRunLoopServiceMachPort</span>(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *** 因为一些原因被唤醒，开始处理唤醒的原因 *** */</span> </span><br><span class="line">        __<span class="built_in">CFRunLoopLock</span>(rl);</span><br><span class="line">        __<span class="built_in">CFRunLoopModeLock</span>(rlm);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 赋值已经睡眠的时间</span></span><br><span class="line">        rl-&gt;_sleepTime += (poll ? <span class="number">0.0</span> : (<span class="built_in">CFAbsoluteTimeGetCurrent</span>() - sleepStart));</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">        __<span class="built_in">CFPortSetRemove</span>(dispatchPort, waitSet);</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">        __<span class="built_in">CFRunLoopSetIgnoreWakeUps</span>(rl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置非睡眠状态</span></span><br><span class="line">	__<span class="built_in">CFRunLoopUnsetSleeping</span>(rl);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* *** 通知 *** */</span></span><br><span class="line">        <span class="comment">// 通知观察者runloop睡眠结束 kCFRunLoopAfterWaiting</span></span><br><span class="line">	<span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopAfterWaiting</span>)) __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopAfterWaiting</span>);</span><br><span class="line">	<span class="comment">/* *** end *** */</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 开始处理消息</span></span><br><span class="line">        handle_msg:;</span><br><span class="line">        <span class="comment">// 设置无视睡眠</span></span><br><span class="line">        __<span class="built_in">CFRunLoopSetIgnoreWakeUps</span>(rl);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理唤醒的原因</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL == livePort) &#123;</span><br><span class="line">            <span class="comment">// 没有被任意的machport端口唤醒</span></span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_NOTHING</span>();</span><br><span class="line">            <span class="comment">// handle nothing</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">        	<span class="comment">// 被wakeupport端口唤醒， 上层上一般是通过CFRunLoopWakeUp产生的唤醒</span></span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_WAKEUP</span>();</span><br><span class="line">            <span class="comment">// do nothing on Mac OS</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* *** 处理Timer *** */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">        	<span class="comment">// 由于mode的timerport fire了被唤醒</span></span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_TIMER</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理Model上的所有timers</span></span><br><span class="line">            <span class="keyword">if</span> (!__<span class="built_in">CFRunLoopDoTimers</span>(rl, rlm, mach_absolute_time())) 			&#123;</span><br><span class="line">                <span class="comment">// 重新设置timer下一个触发的时间</span></span><br><span class="line">                __<span class="built_in">CFArmNextTimerInMode</span>(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* *** end *** */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* *** 如果当前是主线程，处理GCD dispatch到主线程上的block *** */</span></span><br><span class="line">		<span class="comment">// 因为如果不是主线程 dispatchPort就不会被赋值，也就走上面的逻辑了</span></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">        	<span class="comment">// 当前是主线程， 且有block dispatch到主线程上</span></span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_DISPATCH</span>();</span><br><span class="line">            __<span class="built_in">CFRunLoopModeUnlock</span>(rlm);</span><br><span class="line">            __<span class="built_in">CFRunLoopUnlock</span>(rl);</span><br><span class="line">            _<span class="built_in">CFSetTSD</span>(__<span class="built_in">CFTSDKeyIsInGCDMainQ</span>, (<span class="keyword">void</span> *)<span class="number">6</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 处理主线程的block</span></span><br><span class="line">            __<span class="built_in">CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span>(msg);</span><br><span class="line">            _<span class="built_in">CFSetTSD</span>(__<span class="built_in">CFTSDKeyIsInGCDMainQ</span>, (<span class="keyword">void</span> *)<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            __<span class="built_in">CFRunLoopLock</span>(rl);</span><br><span class="line">            __<span class="built_in">CFRunLoopModeLock</span>(rlm);</span><br><span class="line">            sourceHandledThisLoop = <span class="literal">true</span>;</span><br><span class="line">            didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">		<span class="comment">/* *** end *** */</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* *** 处理source1上的消息 *** */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_SOURCE</span>();</span><br><span class="line">            <span class="comment">// Despite the name, this works for windows handles as well</span></span><br><span class="line">            <span class="comment">// 找到具体的source1里的source</span></span><br><span class="line">            <span class="built_in">CFRunLoopSourceRef</span> rls = __<span class="built_in">CFRunLoopModeFindSourceForMachPort</span>(rl, rlm, livePort);</span><br><span class="line">            <span class="keyword">if</span> (rls) &#123;</span><br><span class="line">		mach_msg_header_t *reply = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">// 处理Source1的消息</span></span><br><span class="line">                <span class="comment">// __CFRunLoopDoSource1会调用__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__，进而调用source1上的perform函数</span></span><br><span class="line">		sourceHandledThisLoop = __<span class="built_in">CFRunLoopDoSource1</span>(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">		<span class="comment">// 具体的perform函数的返回值reply msg非空</span></span><br><span class="line">		<span class="comment">// 把reply消息发送回消息的来源，告知消息处理完了</span></span><br><span class="line">		    (<span class="keyword">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">		    <span class="built_in">CFAllocatorDeallocate</span>(k<span class="built_in">CFAllocatorSystemDefault</span>, reply);</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) 			free(msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* *** 处理通过CFRunLoopPerformBlock 加入的block *** */</span></span><br><span class="line">		__<span class="built_in">CFRunLoopDoBlocks</span>(rl, rlm);</span><br><span class="line">		<span class="comment">/* *** end *** */</span></span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* *** 处理当次loop的结果 非0则退出loop *** */</span></span><br><span class="line">	<span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">        <span class="comment">// 处理完了source 处理了source并且上层传入的入参决定调用后需要停止</span></span><br><span class="line">	    retVal = k<span class="built_in">CFRunLoopRunHandledSource</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            <span class="comment">// 时间片到了</span></span><br><span class="line">            retVal = k<span class="built_in">CFRunLoopRunTimedOut</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__<span class="built_in">CFRunLoopIsStopped</span>(rl)) &#123;</span><br><span class="line">        <span class="comment">// runloop停止了</span></span><br><span class="line">            __<span class="built_in">CFRunLoopUnsetStopped</span>(rl);</span><br><span class="line">	    retVal = k<span class="built_in">CFRunLoopRunStopped</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">        <span class="comment">// mode被停止了</span></span><br><span class="line">	    rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">	    retVal = k<span class="built_in">CFRunLoopRunStopped</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__<span class="built_in">CFRunLoopModeIsEmpty</span>(rl, rlm, previousMode)) &#123;</span><br><span class="line">        <span class="comment">// 没有mode了，直接finish loop</span></span><br><span class="line">	    retVal = k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    <span class="comment">/* *** end *** */</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">    <span class="keyword">if</span> (timeout_timer) &#123;</span><br><span class="line">        <span class="comment">// 取消超时的定时器</span></span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">    &#123;</span><br><span class="line">        free(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#####【1】关于portSet<br>一个thread中最多只能有一个拥有接收权限的portSet，(拥有接收权限的port可以很多)，虽然porSet也是个mach_port_t，不过它可以包含很多个machport作为他的member，这一整个集合就会表现的像一个port一样。如果是通过portSet去接收mach msg，他会从任意一个接收到了消息的member的消息队列中取出消息。</p>
<p>每个Mode初始化创建的时候，timer port、source port，waitPort都会加到这个portSet中。</p>
<p>#####【2】关于__CFRunLoopDoBlocks()与CFRunloopPerformBlock()<br>CoreFundation提供了CFRunloopPerformBlock()这个方法，能将一个block显示的放到特定的Runloop的特定的Mode上的block链表中，等待执行。</p>
<p>和gcd的区别在于，gcd是直接将block放到common mode上，而前者可指定mode，以及gcd的会主动wake up runloop(主线程甚至有专门处理的gcd的port)，而CFRunloopPerformBlock()并不会wake up runloop，如果你不手动wake up，那么这个block只能等其他事件把runloop唤醒了，在__CFRunLoopDoBlocks()函数中被处理。</p>
<p>#####【3】关于__CFRunLoopServiceMachPort()函数</p>
<p>__CFRunLoopServiceMachPort里面有个for循环，通过调用了用户态的mach_msg()函数，而后者会通过内核的Mach陷阱机制调用mach_msg_trap()，然后mach_msg_trap()会调用mach_msg_overwrite_trap(),mach_msg_overwrite_trap()通过入参的标识，来判断是发送消息还是接收消息，从而进行IPC。</p>
<p>另外__CFRunLoopServiceMachPort在mach_msg()前还会调用CFRUNLOOP_SLEEP()，之后调CFRUNLOOP_WAKEUP()，不过是闭源的。</p>
<p>#####【4】防止尾递归优化<br>Runloop中很多方法由于内部逻辑场景很可能会被编译器尾递归优化，比如<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong>、<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong>等函数，但苹果在这些函数内部最后都加了条</p>
<pre><code><span class="function">asm <span class="title">__volatile__</span><span class="params">(<span class="string">""</span>)</span></span>;
</code></pre><p>来防止尾递归优化，可能出于debug考虑，这个几个函数调用的栈帧对debug挺重要的。</p>
<h5 id="【5】In_that_sleep_of_death_what_nightmares_may_come">【5】In that sleep of death what nightmares may come</h5><p>在【3】中的__CFRunLoopServiceMachPort函数中，在调用mach_msg()的for之前苹果注释了句话:</p>
<p><strong><em> //In that sleep of death what nightmares may come</em></strong></p>
<p>估计是出自《哈姆雷特》第三章，原文：</p>
<p><strong><em>For in that sleep of death what dreams may come</em></strong></p>
<p>然后把dreams改为了nightmares，苹果工程师真是因缺思厅 : )</p>
<h3 id="结尾">结尾</h3><p>语言不管怎么变，设计和思想是永远能借用的，RunLoop设计非常值得借鉴与思考，未来有空看看安卓的Looper的源码。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/22/OSX_task_for_pid()_FAILURE/" itemprop="url">
                  OSX ElCapitan之后task_for_pid() MACH陷阱调用结果KERN_FAILURE原因与解决方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-22T20:52:20+08:00" content="2016-06-22">
              2016-06-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Mac/" itemprop="url" rel="index">
                    <span itemprop="name">Mac</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Mac/Mach/" itemprop="url" rel="index">
                    <span itemprop="name">Mach</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/22/OSX_task_for_pid()_FAILURE/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/22/OSX_task_for_pid()_FAILURE/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h4 id="task_for_pid()调用失败">task_for_pid()调用失败</h4><p>刚刚写代码中想用task_for_pid()这个Mach陷阱来返回任务id，但是结果总是<code>KERN_FAILURE(5)</code>。</p>
<p>自己排查了一番，发现是OSX(macOS) ElCapitan之后加入的<code>System Integrity Protection</code>特性有关，也就是<code>rootless</code>。</p>
<h4 id="什么是System_Integrity_Protection">什么是System Integrity Protection</h4><p>SIP是El Capitan中引入的一项安全特性。它能保护一些系统进程，文件，文件夹。即使其他进程以root权限（加sudo）来修改上述的东西，都会失败。</p>
<p>由此可见，我们自己代码下的很多进程相关的系统调用或者Mach陷阱都会失败。</p>
<h4 id="怎么关闭System_Integrity_Protection">怎么关闭System Integrity Protection</h4><p>这项技术本身能非常好的保护mac，但有些时候实在需要关闭一下，那么只要：</p>
<p><code>重启</code>mac，按下<code>command + R</code>键进入<code>Recovery模式</code></p>
<p>进入之后点击上面bar中的<code>工具(Utilities)</code>,选择<code>终端(Terminal)</code></p>
<p>然后在终端中输入</p>
<pre><code>csrutil <span class="built_in">disable</span>
</code></pre><p>重启mac，SIP就关闭了，接下去就可以肆无忌惮了。</p>
<p>如果想恢复，直接在终端中输入csrutil enable就行。</p>
<h4 id="结果">结果</h4><p>重启之后，task_for_pid成功返回了pid对应的task id : )</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/20/OCRuntime-Associate/" itemprop="url">
                  Objective-C Runtime源码解析之Associate
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-04-20T00:18:33+08:00" content="2016-04-20">
              2016-04-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/20/OCRuntime-Associate/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/20/OCRuntime-Associate/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="Objective-C_Runtime源码解析之Associate">Objective-C Runtime源码解析之Associate</h2><h3 id="方法简介">方法简介</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span></span><br></pre></td></tr></table></figure>
<p>功能： 为一个对象以key-value的形式关联一个对象</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br></pre></td></tr></table></figure>
<p>功能：以key-value的形式从一个对象中获取一个关联的对象</p>
<h3 id="应用场景">应用场景</h3><p>这两个运行时方法，一般在日常开发中还是经常会用到。</p>
<p>主要是向一个已经regist的类以k-v的形式关联值，达到property的作用。</p>
<p>比如通过associate在category中加‘存储属性’</p>
<p><strong>这篇博客就不具体介绍使用场景了，主要还是看看associate机制的内部实现原理。</strong></p>
<h3 id="深入源码">深入源码</h3><p>不管是setAssociatedObject还是getAssociatedObject，都有2个版本，以get为例，一个是非gc的</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject_non_gc</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>而另一个是gc的</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_getAssociatedObject_gc(id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br></pre></td></tr></table></figure>
<p>作为iOS日常开发，接触的自然是非gc，那么看看non_gc版本的底层实现。</p>
<p>内部调用了私有方法</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">_</span><span class="keyword">object</span><span class="number">_</span>set<span class="number">_</span>associative<span class="number">_</span>reference(<span class="keyword">object</span>, (<span class="keyword">void</span> *)key, <span class="keyword">value</span>, policy)</span><br></pre></td></tr></table></figure>
<p>查看该方法，可得出整个过程是：</p>
<h4 id="objc_getAssociatedObject过程">objc_getAssociatedObject过程</h4><ol>
<li>调用objc_getAssociatedObject_non_gc</li>
<li>调用_object_get_associative_reference</li>
<li>以组合对象object的地址取反作为key，取出包含了该对象所有关联值的map</li>
<li>以传入的key作为key，取出map中的值，是一个关联值与policy的包装类</li>
<li>根据associate的策略，对取出的包装类中的value send对应的内存管理msg: retain/autorelease</li>
<li>返回value</li>
</ol>
<h4 id="objc_setAssociatedObject过程">objc_setAssociatedObject过程</h4><ol>
<li>调用objc_setAssociatedObject_non_gc</li>
<li>调用_object_set_associative_reference</li>
<li>以组合对象object的地址取反作为key，取出包含了该对象所有关联值的map, 如果没有则创建一个</li>
<li>创建ObjcAssociation包装value与policy，以传入的key作为key，set ObjcAssociation到map中</li>
<li>根据associate的策略，对取出的value发送对应的内存管理消息retain/autorelease</li>
<li>其中 在第2部后，如果value是空，则是查找到map后，取出老的value，删除对应的key与value，并根据policy release老的value</li>
</ol>
<h3 id="详解其中用到的类">详解其中用到的类</h3><h3 id="AssociationsManager">AssociationsManager</h3><p>associate主要依靠于<strong>AssociationsManager</strong>的类来管理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AssociationsManager &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">spinlock_t</span> _lock;</span><br><span class="line">    <span class="keyword">static</span> AssociationsHashMap *_map;               <span class="comment">// associative references:  object pointer -&gt; PtrPtrHashMap.</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AssociationsManager()   &#123; spinlock_lock(&amp;_lock); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; spinlock_unlock(&amp;_lock); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_map == <span class="literal">NULL</span>)</span><br><span class="line">            _map = <span class="keyword">new</span> AssociationsHashMap();</span><br><span class="line">        <span class="keyword">return</span> *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简要介绍下这两个静态变量</p>
<h4 id="spinlock_t_线程安全">spinlock_t 线程安全</h4><p>每次去set或者get关联对象是，都会创建一个AssociationsManager的临时变量，在构造方法中使自旋锁加锁，析构方法中解锁，从而达到线程安全。</p>
<p>在这个场景由于是自旋锁，所以对性能影响较小。</p>
<h4 id="AssociationsHashMap_内部存储">AssociationsHashMap 内部存储</h4><p>AssociationsManager中有个懒加载的属性associations，返回了静态变量: <code>AssociationsHashMap</code> _map</p>
<p>全局有且仅有1个AssociationsHashMap</p>
<p>AssociationsHashMap是个STL的<code>unordered_map</code>的子类，存储运行时下<code>所有 有关联值的 对象</code>的相关数据</p>
<p><strong>key</strong>: 被组合对象的<strong>地址取反</strong></p>
<p><strong>value</strong>: 继承自STL的<code>map</code>的子类<code>ObjectAssociationMap</code></p>
<h4 id="ObjectAssociationMap">ObjectAssociationMap</h4><p>ObjectAssociationMap存储了<code>某一个具体对象</code>的<code>所有关联值</code></p>
<p><strong>key</strong>: 上层方法传入的<strong>const void *key</strong></p>
<p><strong>value</strong>: 一个class <strong>ObjcAssociation</strong> </p>
<h4 id="ObjcAssociation">ObjcAssociation</h4><p>ObjcAssociation包装了关联值的内存策略_policy， 以及具体的value</p>
<pre><code><span class="keyword">class</span> ObjcAssociation {
        <span class="keyword">uintptr_t</span> _policy;
        id _value;
    <span class="keyword">public</span>:
        ObjcAssociation(<span class="keyword">uintptr_t</span> policy, id value) : _policy(policy), _value(value) {}
        ObjcAssociation() : _policy(<span class="number">0</span>), _value(nil) {}

        <span class="keyword">uintptr_t</span> policy() <span class="keyword">const</span> { <span class="keyword">return</span> _policy; }
        <span class="function">id <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> _value; }

        <span class="function"><span class="keyword">bool</span> <span class="title">hasValue</span><span class="params">()</span> </span>{ <span class="keyword">return</span> _value != nil; }
    };
</code></pre><h3 id="总结">总结</h3><ul>
<li>Associate是依靠AssociationsManager来管理实现，其中有个静态全局的map</li>
<li>存放关联值的形式近似可看成是map中套了个map，外层map映射了 有关联值 的对象，内层map映射了对象中具体的关联值</li>
<li>Associate是线程安全的</li>
<li>只看从map取值这个过程来看，时间复杂度大概是O(logN),效率还是挺高的 (ps: map内部是个红黑树，复杂度是O(logN), unordered_map内部是个hash表，时间复杂度可认为是O(1))</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/23/深入Swift/" itemprop="url">
                  深入Swift
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-03-23T00:23:42+08:00" content="2016-03-23">
              2016-03-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/23/深入Swift/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/23/深入Swift/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="深入Swift">深入Swift</h2><p>主要介绍Swift的一些内部实现吧，对于实际开发倒是用处不是太大(笑</p>
<h3 id="Class_object">Class object</h3><p>Swift类实际上而言就是Objective-C类，在llvm的llvm-objdump<a href="https://github.com/devxoul/CocoaSeeds&quot;" target="_blank" rel="external">源码</a>中可以找到objc_class结构类似于这样:</p>
<pre><code><span class="comment">// The class object in a 64-bit Mach-O file.</span>
    <span class="keyword">struct</span> <span class="keyword">class64_t</span> {
      <span class="keyword">uint64_t</span> isa;        <span class="comment">// class64_t * (64-bit pointer)</span>
      <span class="keyword">uint64_t</span> superclass; <span class="comment">// class64_t * (64-bit pointer)</span>
      <span class="keyword">uint64_t</span> cache;      <span class="comment">// Cache (64-bit pointer)</span>
      <span class="keyword">uint64_t</span> vtable;     <span class="comment">// IMP * (64-bit pointer)</span>
      <span class="keyword">uint64_t</span> data;       <span class="comment">// class_ro64_t * (64-bit pointer)</span>
    };
</code></pre><p>其中data指向了一个结构体，内容是类的ivar、method、protocol之类</p>
<pre><code><span class="keyword">struct</span> <span class="keyword">class_ro64_t</span> {
  <span class="keyword">uint32_t</span> flags;
  <span class="keyword">uint32_t</span> instanceStart;
  <span class="keyword">uint32_t</span> instanceSize;
  <span class="keyword">uint32_t</span> reserved;
  <span class="keyword">uint64_t</span> ivarLayout;     <span class="comment">// const uint8_t * (64-bit pointer)</span>
  <span class="keyword">uint64_t</span> name;           <span class="comment">// const char * (64-bit pointer)</span>
  <span class="keyword">uint64_t</span> baseMethods;    <span class="comment">// const method_list_t * (64-bit pointer)</span>
  <span class="keyword">uint64_t</span> baseProtocols;  <span class="comment">// const protocol_list_t * (64-bit pointer)</span>
  <span class="keyword">uint64_t</span> ivars;          <span class="comment">// const ivar_list_t * (64-bit pointer)</span>
  <span class="keyword">uint64_t</span> weakIvarLayout; <span class="comment">// const uint8_t * (64-bit pointer)</span>
  <span class="keyword">uint64_t</span> baseProperties; <span class="comment">// const struct objc_property_list (64-bit pointer)</span>
};        
</code></pre><p>和之前Objective-C runtime源码上的类没什么区别，主要是多了<code>vtable</code>这个入口，是个IMP(C 方法指针) *的数据结构，说明Swift确实用了vtable实现方法调用</p>
<h3 id="Swift基类">Swift基类</h3><p>Swift表面上不需要继承基类，但是参看<a href="https://github.com/apple/swift" target="_blank" rel="external">Swift源码</a>，可以知道Swift还是有一个叫<code>SwiftObject</code>的Objective-C root类且实现了NSObject协议</p>
<pre><code><span class="annotation">@interface</span> SwiftObject&lt;NSObject&gt; {
  <span class="keyword">void</span> *<span class="function">magic_isa  <span class="title">__attribute__</span><span class="params">((unavailable)</span>)</span>;
  <span class="function"><span class="keyword">long</span> magic_refCount  <span class="title">__attribute__</span><span class="params">((unavailable)</span>)</span>;
}
</code></pre><p>这个类目的之一是使Swift的类在alloc、retain等一些列操作时能运行Swift的runtime方法而不是Objective-C的</p>
<pre><code>- (<span class="keyword">void</span>)release {
      <span class="keyword">auto</span> SELF = <span class="keyword">reinterpret_cast</span>&lt;HeapObject *&gt;(self);
      swift_release(SELF);
}
</code></pre><h3 id="Method">Method</h3><p>Swift方法调用在条件满足的情况下会尽可能的被优化成<code>内联</code>，否则一般情况下是<code>vtable dispatch</code>，这也是运行效率提升主要的点。</p>
<p>在vtable中方法是IMP(c方法指针),而不是Objective-C中常见的Method，自然也无法被Objective-C的runtime获取到。</p>
<p>当方法被<code>dynamic</code>标记时，会强行走dynamic dispatch 也就是msgSend那一套。</p>
<p>当方法<code>@objc</code>标记时，官方也说不一定走动态派发，但是在这个情况下该方法确实能用Objective-C的runtime获取到。<em>所以个人猜测，@objc标记的方法既会在vtable中存在，也会在baseMethods中存在</em>，从而Swift侧不会影响效率，而Objective-C侧还是可以调用到。</p>
<h3 id="Property_&amp;_ivar">Property &amp; ivar</h3><p>在Swift中Property和ivar的结构与Objective-C是一样，且都能被Objective-C的runtime相关方法获取到。写了个Demo测了下发现有几个坑：</p>
<ul>
<li>通过Objective-C runtime获取到的ivar的<code>TypeEncoding</code>永远是空 : (</li>
<li>Swift调用属性时和Objective-C不同，可能<code>是内联的</code>,比如即使你hook了属性的set方法，但是对实际属性的set很可能没任何影响。</li>
</ul>
<h3 id="Name_mangling">Name mangling</h3><p>Swift的所有类，方法等都是会被Name mangling，所以也就自然支持了方法重载、命名空间等，以后用Swift写iOS终于可以不用写超长的前缀了: )</p>
<p>这边有个比较重要的坑是:<br>通过Objective-C Runtime获取自己工程<code>OCProjectDemo</code>中的一个swift类，比如<code>Adapter</code>,mangle后类名会变成<code>OCProjectDemo.Adapter</code>(更确切地说是<code>_TtC13OCProjectDemo7Adapter</code>)</p>
<p>所以想通过运行时相关方法创建类的实例的话，类名需要加上<code>ModuleName.</code>前缀。</p>
<hr>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/23/SwiftPractise/" itemprop="url">
                  实战后的Swift语言感想
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-03-23T00:18:00+08:00" content="2016-03-23">
              2016-03-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/23/SwiftPractise/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/23/SwiftPractise/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="实战后的Swift语言简单感想">实战后的Swift语言简单感想</h2><p>最近，项目中用Swift重写一整个模块，简单分享下Swift相对于OC上的感受。</p>
<h2 id="Swift语言">Swift语言</h2><p><em>Swift. A modern programming language that is safe, fast, and interactive.</em></p>
<p>这是官方的介绍，主要就是<code>安全、快速、交互</code>。<br>实际使用中，和Objective-C对比较大的区别是：</p>
<h3 id="1-静态语言_&amp;_Strong_type_System">1.静态语言 &amp; Strong type System</h3><p>下文前提: 指的是<code>纯粹</code>的Swift。因为只要你愿意，只要在swift中使用@objc、dynamic或者继承NSObject，还是能获得绝大多数Objective-C的能力。</p>
<p>Swift没有Objective-C般强大Runtime。函数调用也不再是Objective-C的消息派发，而是直接调用或者vtable。这也是swift运行速度比Objective-C快的一个最主要的原因。不过另一方面 就no more kvo, no more method swizzle， no more isa swizzle。</p>
<p>另外Swift是个强类型语言，并去掉了id这个比较<code>万能</code>的指针，强调了类型安全。能最大程度的避免unrecognized method。</p>
<h3 id="2-Powerful_Value_type">2.Powerful Value type</h3><p>Swift在很多场景下，官方更推荐使用value type。与Objective-C不同,系统库中绝大部分包括数组(Array)、字典(Dictionary)、字符串(String)都设计成了Value type。</p>
<p>因为Value type在绝大部分场景下<code>性能</code>与<code>安全</code>远优于Reference Type的（PS: Swift的Struct值传递是写时拷贝的)</p>
<p>此外value type比重加大另外一个原因是struct和enum，可以<code>添加方法</code>，可以<code>实现协议</code>，使得能力异常强大。</p>
<h3 id="3-Protocol-Oriented_Programming">3.Protocol-Oriented Programming</h3><p>面向协议编程是去年苹果在WWDC的同名Session中提出的，配合<code>generics(范型)</code>，非常有趣 简而言之:</p>
<ul>
<li>Protocols &gt; Superclasses</li>
<li>Protocol extensions = magic (almost)</li>
</ul>
<p>具体可直接看苹果在Swift系统库中对Protocol优雅的使用。</p>
<p>比如最基本Int类型(是个struct)，就由SignedIntegerType、 Comparable、Equatable、RandomAccessIndexType、Hashable、CustomStringConvertible、SignedNumberType、BitwiseOperationsType、_Reflectable等一些列协议组成。</p>
<p>不过不是说啥地方都一股脑用协议，苹果有句话很好：<em>Don’t fight the system</em> 在很多系统要求class的地方还是得class，特别是和Cocoa Touch打交道的时候，深有感触。</p>
<p>PS: protocol extensions: 可以给已经存在的protocol增加新的方法并提供默认实现</p>
<h3 id="4-Modern_language">4.Modern language</h3><p>其实也就是吸收了很多现代语言语言的优点，对比Objective-C，实际编码中主要的印象深刻以及有用的是</p>
<ul>
<li>末尾不用加分号</li>
<li>方法调用不用[]</li>
<li>定义变量直接用let、var就ok了</li>
<li>闭包语法更加简洁,对比Objective-C的block</li>
<li>swich可以匹配int之外的数据结构</li>
<li>enum的raw value可以是int外的结构了，enum还能携带其他的值</li>
<li>操作符重载，generics(范型)等等</li>
<li>map、reduce、flatmap、filter等高阶函数，真的爽，爽出声</li>
<li>配合类型推倒，让你感觉Swift是一门<code>简洁</code>的语言,简了又简</li>
</ul>
<p>举例：对一个数组names进行排序</p>
<p>原版：</p>
<pre><code><span class="label">func</span> <span class="keyword">backwards(s1: </span><span class="keyword">String, </span>_ <span class="literal">s2</span>: <span class="keyword">String) </span>-&gt; <span class="keyword">Bool </span>{
    return <span class="literal">s1</span> &gt; <span class="literal">s2</span>
}
<span class="label">var</span> <span class="keyword">reversed </span>= names.sort(<span class="keyword">backwards)</span>
</code></pre><p>超级简洁版：</p>
<pre><code>reversed = names.sort{ <span class="variable">$0</span> &gt; <span class="variable">$1</span> }
</code></pre><p>简洁威力加强版：</p>
<pre><code>reversed = names.<span class="function"><span class="title">sort</span><span class="params">(&gt;)</span></span>
</code></pre><h3 id="5-安全">5.安全</h3><p>Swift中处处都能透露出安全的气息。除了之前说的几点使安全提升外，比较重要的就是<code>optional value</code>: 对于变量，可以表示出<code>有值</code>与<code>没值</code>两个状态。（ps:内部实现其实就是个范型的enum, 有None和Some两种类型）。</p>
<p>取值时，必须<code>先解包</code>才能取值，这个过程就会使开发者每次调用变量时必定会去注意变量的nil情况，从而减少bug。</p>
<p>对于解包，个人认为，优秀的Swift代码应当尽可能多使用可失败的解包(if let、 as?)而不是隐式解包(! 解包失败会直接crash)。</p>
<p>此外Swift还去掉了指针等一大堆不安全的部分(当然还是提供了一套unsafe开头的api能间接操控)。</p>
<hr>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/04/SwiftExtension中的方法派发/" itemprop="url">
                  Swift Protocol Extension中的方法派发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-01-04T00:06:45+08:00" content="2016-01-04">
              2016-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/04/SwiftExtension中的方法派发/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/04/SwiftExtension中的方法派发/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h3 id="Swift_Protocol_Extension中的方法派发">Swift Protocol Extension中的方法派发</h3><h4 id="最近在玩Swift，总体挺有趣，但偶尔会碰到坑，基本都是静态类型的特性导致的。其中在Protocol的Extension中突遇大坑。">最近在玩Swift，总体挺有趣，但偶尔会碰到坑，基本都是静态类型的特性导致的。其中在Protocol的Extension中突遇大坑。</h4><h5 id="简要介绍下Protocol_Extension">简要介绍下Protocol Extension</h5><p> <em>Swift 2.0后新推出的特性，可以给已有的协议增加方法以及非存储型的实例变量，<strong>并拥有方法实现</strong></em>。</p>
<p>Protocol Extension作为面向协议编程中极为重要的一个工具，日常中经常会用到，且确实如苹果所说，简直就是magic。</p>
<p>对于我个人而言，Swift的extension或者OC的category，经常会用来践行单一职责的设计思想。</p>
<h5 id="很日常的场景与问题">很日常的场景与问题</h5><p>协议扩展里有方法A，实现了协议的class或struct中也有A方法，并拥有自己的实现。然后用协议类型的变量指向那些class的实例，并调用A方法</p>
<p>然后这边出现的一个巨大问题： 用extension给Potocol增加的方法，没有“多态性”！<del>这里可能不能叫动态，毕竟协议不算是子类，但大致就是这个意思</del></p>
<h5 id="举个栗子">举个栗子</h5><p>定义一个基础的协议People：</p>
<pre><code>protocol People {
    <span class="variable"><span class="keyword">var</span> name</span>: String { <span class="keyword">get</span> }
    <span class="variable"><span class="keyword">var</span> age</span>: <span class="typename">Int</span> { <span class="keyword">get</span> }
<span class="comment">//    var hobbies: [String] { get }</span>
}
</code></pre><p>通过extension给People增加成员变量Hobby</p>
<pre><code><span class="comment">// MARK: - Hobby</span>
<span class="class"><span class="keyword">extension</span> <span class="title">People</span> </span>{
    <span class="keyword">var</span> hobbies: [<span class="type">String</span>] {
        <span class="built_in">print</span>(<span class="string">"Base Protocol extension hobbies"</span>)
        <span class="keyword">return</span> []
    }
}
</code></pre><p>定义2个实现了协议的类，其中Archer的hobby方法通过extension增加，为了增加栗子的case</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Archer</span>: <span class="typename">People {</span></span>
    <span class="variable"><span class="keyword">var</span> name</span> = <span class="string">"Emiya"</span>
    <span class="variable"><span class="keyword">var</span> age</span> = <span class="number">18</span> <span class="comment">// 瞎写的</span>
}

<span class="comment">// MARK: - Hobby of Archer</span>
extension Archer {
    <span class="variable"><span class="keyword">var</span> hobbies</span> : [String] {
        print(<span class="string">"Archer class's extension hobby"</span>)
        <span class="keyword">return</span> [<span class="string">"Shoot"</span>, <span class="string">"Rin"</span>]
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">Saber</span>: <span class="typename">People {</span></span>
    <span class="variable"><span class="keyword">var</span> name</span> = <span class="string">"Altria"</span>
    <span class="variable"><span class="keyword">var</span> age</span> = <span class="number">100000</span> <span class="comment">// 瞎写的</span>
    <span class="variable"><span class="keyword">var</span> hobbies</span>: [String] {
        <span class="keyword">get</span> {
            print(<span class="string">"Saber class's origin hobby"</span>)
            <span class="keyword">return</span> [<span class="string">"Eat"</span>,<span class="string">"Lion"</span>]
        }
    }
}
</code></pre><p>尝试调用</p>
<pre><code><span class="tag">var</span> aPeople: People
<span class="tag">var</span> archer = <span class="function"><span class="title">Archer</span><span class="params">()</span></span>
<span class="tag">var</span> saber = <span class="function"><span class="title">Saber</span><span class="params">()</span></span>

aPeople = archer <span class="comment">// 推断为People的变量指向archer</span>


archer<span class="class">.hobbies</span> <span class="comment">//  ["Shoot", "Rin"]</span>
saber<span class="class">.hobbies</span> <span class="comment">// ["Eat", "Lion"]</span>
aPeople<span class="class">.hobbies</span> <span class="comment">//!意料之外 []</span>

aPeople = saber
aPeople<span class="class">.hobbies</span> <span class="comment">//!意料之外 []</span>
</code></pre><p>原本预想aPeople.hobbies会调用运行时实际类型的方法，然而却调用了协议的extension的默认实现</p>
<p>尝试在协议中增加hobby变量，（去掉注释</p>
<pre><code>protocol People {
        <span class="variable"><span class="keyword">var</span> name</span>: String { <span class="keyword">get</span> }
        <span class="variable"><span class="keyword">var</span> age</span>: <span class="typename">Int</span> { <span class="keyword">get</span> }
        <span class="variable"><span class="keyword">var</span> hobbies</span>: [String] { <span class="keyword">get</span> }
}
</code></pre><p>调用结果</p>
<pre><code><span class="tag">var</span> aPeople: People
<span class="tag">var</span> archer = <span class="function"><span class="title">Archer</span><span class="params">()</span></span>
<span class="tag">var</span> saber = <span class="function"><span class="title">Saber</span><span class="params">()</span></span>

aPeople = archer <span class="comment">// 类型为People的变量指向archer</span>


archer<span class="class">.hobbies</span> <span class="comment">//  ["Shoot", "Rin"]</span>
saber<span class="class">.hobbies</span> <span class="comment">// ["Eat", "Lion"]</span>
aPeople<span class="class">.hobbies</span> <span class="comment">//!!["Shoot", "Rin"]</span>

aPeople = saber
aPeople<span class="class">.hobbies</span> <span class="comment">//!! ["Eat", "Lion"]</span>
</code></pre><p>“正确”的调用了真正类型的方法</p>
<h4 id="结论">结论</h4><p>对于调用某实例的A方法时</p>
<p>if A是通过Protocol Extension增加的 &amp;&amp; 协议本身没声明A &amp;&amp; 当前实例的编译器推断类型是Protocol</p>
<ul>
<li>则调用Protocol的Extension中的该方法的实现。</li>
</ul>
<p>else</p>
<ul>
<li>调用运行时该实例真正的Type的对应的方法</li>
</ul>
<p><em>Swift目前这个版本是这样的，不知是苹果的有意为之还是只是一个Bug</em></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/31/2015就要结束了/" itemprop="url">
                  2015，Good bye
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-12-31T23:49:20+08:00" content="2015-12-31">
              2015-12-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/日常/" itemprop="url" rel="index">
                    <span itemprop="name">日常</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/31/2015就要结束了/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/31/2015就要结束了/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>2015就这么结束了，回望这一年，过的还是挺开心并充满收获的。</p>
<h4 id="技术上">技术上</h4><p>从春招前到实习入职前，从实习入职到秋招(转正面试)前，从秋招到现在，每次从某个时间段的终点回望该时间段起点，总是能感受到自己提升了很多，包括技术、视野、思想等。年底搭了个博客，想着写点技术分享，可惜啥都没写（笑。</p>
<h4 id="生活上">生活上</h4><p>感觉在阿里实习的挺开心，遇见了有趣的人们，有趣的团队，有趣的生活。并充分融入了这里。</p>
<h4 id="展望2016">展望2016</h4><p>新的一年，技术上还是打算往全栈发展，说到底，语言只是一个工具，iOS终究也只是个方向而已，总是局限在这一块，只会限制自己的视野而已，iOS、安卓、服务端、前端、机器学习等等都有一定学习，可能是更好的方向。</p>
<p>展望2016，毕业、入职，又是人生的新阶段了。</p>
<p>Hello 2016,Stay hungry,stay foolish.</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  


        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/uploads/avatar.png" alt="SatoshiChin" itemprop="image"/>
          <p class="site-author-name" itemprop="name">SatoshiChin</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Think different</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://www.weibo.com/u/2840829854" target="_blank">
                  
                    <i class="fa fa-globe"></i> weibo
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SatoshiChin</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"satoshichin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>

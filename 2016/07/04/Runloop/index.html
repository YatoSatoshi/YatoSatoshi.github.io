<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Objective-C,iOS,RunLoop,源码解析,CFRunloop,mach_msg" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="CoreFundation源码解析之RunLoop
什么是RunLoopRunLoop就是组合在线程上的一部分基础设施，用来处理事件的循环。
我觉得runloop比起通常的do-while循环来说，提供的最重要的能力是使线程能在需要工作的时候工作，而不需要工作的睡眠（操作系统上就是进入wating的队列，从而让出cpu资源(时间片)），增加硬件的使用率。
Runloop主要是定义在CoreFund">
<meta property="og:type" content="article">
<meta property="og:title" content="CoreFundation源码解析之RunLoop">
<meta property="og:url" content="http://blog.SatoshiChin.com/2016/07/04/Runloop/index.html">
<meta property="og:site_name" content="SatoshiChin's blog">
<meta property="og:description" content="CoreFundation源码解析之RunLoop
什么是RunLoopRunLoop就是组合在线程上的一部分基础设施，用来处理事件的循环。
我觉得runloop比起通常的do-while循环来说，提供的最重要的能力是使线程能在需要工作的时候工作，而不需要工作的睡眠（操作系统上就是进入wating的队列，从而让出cpu资源(时间片)），增加硬件的使用率。
Runloop主要是定义在CoreFund">
<meta property="og:updated_time" content="2016-07-03T17:41:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CoreFundation源码解析之RunLoop">
<meta name="twitter:description" content="CoreFundation源码解析之RunLoop
什么是RunLoopRunLoop就是组合在线程上的一部分基础设施，用来处理事件的循环。
我觉得runloop比起通常的do-while循环来说，提供的最重要的能力是使线程能在需要工作的时候工作，而不需要工作的睡眠（操作系统上就是进入wating的队列，从而让出cpu资源(时间片)），增加硬件的使用率。
Runloop主要是定义在CoreFund">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> CoreFundation源码解析之RunLoop | SatoshiChin's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">SatoshiChin's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Stay hungry Stay foolish</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                CoreFundation源码解析之RunLoop
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-07-04T01:05:33+08:00" content="2016-07-04">
              2016-07-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/04/Runloop/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/04/Runloop/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><h2 id="CoreFundation源码解析之RunLoop">CoreFundation源码解析之RunLoop</h2><hr>
<h3 id="什么是RunLoop">什么是RunLoop</h3><p>RunLoop就是组合在线程上的一部分基础设施，用来处理事件的循环。</p>
<p>我觉得runloop比起通常的do-while循环来说，提供的最重要的能力是使线程能在<code>需要工作</code>的时候<code>工作</code>，而<code>不需要工作</code>的<code>睡眠</code>（操作系统上就是进入wating的队列，从而让出cpu资源(时间片)），增加硬件的使用率。</p>
<p>Runloop主要是定义在CoreFundation这一层，暴露一系列C的APi，此外还有个NSRunloop的OC类用来包装成OC的对象。</p>
<p><strong>接下去主要解析的是Runloop的源码上的实现，解析内容大部分直接注释到了源码里，方便观看，ps:中文注释都是我加的，而不是苹果注释的 - -</strong></p>
<h3 id="数据结构定义">数据结构定义</h3><h4 id="CFRunloop">CFRunloop</h4><p>CFRunloop的结构体的定义如下，详细信息注释在代码中</p>
<pre><code>    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_MUTABLE_TYPE</span>(<span class="keyword">id</span>) __<span class="built_in">CFRunLoop</span> *     <span class="built_in">CFRunLoopRef</span>;
<span class="keyword">struct</span> __<span class="built_in">CFRunLoop</span> {
    <span class="built_in">CFRuntimeBase</span> _base;  <span class="comment">// 存储运行时相关数据，类似OC class中的ISA</span>
    pthread_mutex_t _lock; <span class="comment">// 互斥锁，用来在接触mode时加锁</span>
    __<span class="built_in">CFPort</span> _wakeUpPort;    <span class="comment">// CFPort是对mach_port的包装，Api中的CFRunLoopWakeUp方法就是通过向这个端口发消息来唤醒runloop的</span>
    Boolean _unused;
    <span class="keyword">volatile</span> _per_run_data *_perRunData; <span class="comment">// runloop的的一些控制数据，比如能否被唤醒等，每一次loop中都会新建一个</span>
    pthread_t _pthread; <span class="comment">// 和runloop绑定的线程</span>
    <span class="built_in">CFMutableSetRef</span> _commonModes; <span class="comment">// common mode包含的mode的name</span>
    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// common mode中的所有timer、source、observer</span>
    <span class="built_in">CFRunLoopModeRef</span> _currentMode; <span class="comment">// 当前mode</span>
    <span class="built_in">CFMutableSetRef</span> _modes; <span class="comment">// runloop的所有mode</span>
    <span class="comment">// 通过CFRunLoopPerformBlock加入到runloop下的item链表</span>
    <span class="keyword">struct</span> _block_item *_blocks_head; <span class="comment">// block_item链表的头</span>
    <span class="keyword">struct</span> _block_item *_blocks_tail; <span class="comment">// block_item链表的尾</span>
    <span class="built_in">CFAbsoluteTime</span> _runTime; <span class="comment">// 运行的时间</span>
    <span class="built_in">CFAbsoluteTime</span> _sleepTime; <span class="comment">// 睡眠的时间</span>
    <span class="built_in">CFTypeRef</span> _counterpart; 
};
</code></pre><h3 id="Runloop_Mode">Runloop Mode</h3><p>Runloop Mode = Sources + Timers + Observers + others</p>
<p>也就是包含了一些列事件的来源、定时器、观察者和其他的一些数据。</p>
<p>Mode间通过name来区分。Runloop中必须要有Mode，不然不会运行，此外每次loop只能运行在一个mode下，等等可以runloop run的源码中验证。</p>
<p>Core Fundation和Cocoa内置了很多Mode</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Name</th>
<th>Des</th>
</tr>
</thead>
<tbody>
<tr>
<td>Default</td>
<td>NSDefaultRunLoopMode (Cocoa) kCFRunLoopDefaultMode (Core Foundation)</td>
<td>大部分操作都在这个mode下</td>
</tr>
<tr>
<td>Connection</td>
<td>NSConnectionReplyMode (Cocoa)</td>
<td>NSConnection通过这个Mode来监听远端的相应</td>
</tr>
<tr>
<td>Modal</td>
<td>NSModalPanelRunLoopMode (Cocoa)</td>
<td></td>
</tr>
<tr>
<td>Event tracking</td>
<td>NSEventTrackingRunLoopMode (Cocoa)</td>
<td>跟踪滚动等UI相关事件的模式</td>
</tr>
<tr>
<td>Common modes</td>
<td>NSRunLoopCommonModes (Cocoa) kCFRunLoopCommonModes (Core Foundation)</td>
<td>包含了很多经常使用的Mode的结合的Mode。Cocoa中的该模式默认包含了Default、Modal、Event tracking，可以通过CFRunLoopAddCommonMode自由的添加其他mode</td>
</tr>
</tbody>
</table>
<h5 id="Runloop_Mode的数据结构">Runloop Mode的数据结构</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base; <span class="comment">// 运行时相关数据，isa</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;	<span class="comment">// 互斥锁</span></span><br><span class="line">    CFStringRef _name; <span class="comment">// mode的名字</span></span><br><span class="line">    Boolean _stopped; <span class="comment">// mode是否停止</span></span><br><span class="line">    <span class="keyword">char</span> _padding[<span class="number">3</span>]; </span><br><span class="line">    CFMutableSetRef _sources0; <span class="comment">// source0 集合内的类型是CFRunLoopSourceContext</span></span><br><span class="line">    CFMutableSetRef _sources1; <span class="comment">// source1 集合内的类型是CFRunLoopSourceContext1</span></span><br><span class="line">    <span class="comment">// source1和0最大的区别是source1里有mach_port</span></span><br><span class="line">    CFMutableArrayRef _observers; <span class="comment">// mode上的观察者s</span></span><br><span class="line">    CFMutableArrayRef _timers;  <span class="comment">// mode上的定时器s</span></span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;<span class="comment">// machport到soure0的映射</span></span><br><span class="line">    __CFPortSet _portSet; <span class="comment">// mode上的portSet端口，包含很多member，并有用接收msg的权限</span></span><br><span class="line">    CFIndex _observerMask; /</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    <span class="keyword">dispatch_source_t</span> _timerSource;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> _queue;</span><br><span class="line">    Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> _timerPort; <span class="comment">// 定时器相关的mach端口，上面的timers全靠这个port才会被fire</span></span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerSoftDeadline; <span class="comment">/* TSR */</span> <span class="comment">// 所有timer中 fire时间最近的timer的TSR</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerHardDeadline; <span class="comment">/* TSR */</span> <span class="comment">// 所有timer中 fire时间加容忍度时间最近的timer的TSR</span></span><br></pre></td></tr></table></figure>
<h4 id="Runloop_Source">Runloop Source</h4><p>Source代表了事件的来源，可以是基于port的，也可以是自定义的（不过得自己在合适的实际手动触发(signaling)）, 也可是是Perform Selector。</p>
<h4 id="Runloop_Source数据结构">Runloop Source数据结构</h4><pre><code><span class="class"><span class="keyword">struct</span> <span class="title">__CFRunLoopSource</span> {</span>
    <span class="constant">CFRuntimeBase</span> _base;
    uint32_t _bits;
    pthread_mutex_t _lock;
    <span class="constant">CFIndex</span> _order;            <span class="regexp">/* immutable */</span>
    <span class="constant">CFMutableBagRef</span> _runLoops;
    <span class="class"><span class="keyword">union</span> {</span>
    <span class="constant">CFRunLoopSourceContext</span> version0; <span class="regexp">//source</span>0 无port
    <span class="constant">CFRunLoopSourceContext1</span> version1; <span class="regexp">//</span> source1 有port
    } _context;
};
</code></pre><p>__CFRunLoopSource本身没什么好注释的，主要的内容在SourceContext中</p>
<h4 id="CFRunLoopSourceContext">CFRunLoopSourceContext</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span>	version;</span><br><span class="line">    <span class="keyword">void</span> *	info;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="built_in">CFStringRef</span>	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    Boolean	(*equal)(<span class="keyword">const</span> <span class="keyword">void</span> *info1, <span class="keyword">const</span> <span class="keyword">void</span> *info2);</span><br><span class="line">    <span class="built_in">CFHashCode</span>	(*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span>	(*schedule)(<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line">    <span class="keyword">void</span>	(*cancel)(<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line">    <span class="keyword">void</span>	(*perform)(<span class="keyword">void</span> *info); <span class="comment">// signal后的事件函数</span></span><br><span class="line">&#125; <span class="built_in">CFRunLoopSourceContext</span>;</span><br></pre></td></tr></table></figure>
<h4 id="CFRunLoopSourceContext1">CFRunLoopSourceContext1</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span>	version;</span><br><span class="line">    <span class="keyword">void</span> *	info;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="built_in">CFStringRef</span>	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    Boolean	(*equal)(<span class="keyword">const</span> <span class="keyword">void</span> *info1, <span class="keyword">const</span> <span class="keyword">void</span> *info2);</span><br><span class="line">    <span class="built_in">CFHashCode</span>	(*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sourcce1 绑定了mach端口, 这是和source0最大的区别</span></span><br><span class="line">    mach_port_t	(*getPort)(<span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span> *	(*perform)(<span class="keyword">void</span> *msg, <span class="built_in">CFIndex</span> size, <span class="built_in">CFAllocatorRef</span> allocator, <span class="keyword">void</span> *info);</span><br><span class="line">&#125; <span class="built_in">CFRunLoopSourceContext1</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到Source0和Source1最大的区别是Source1拥有mach port，可以自己触发。</p>
<h4 id="Runloop_Timer">Runloop Timer</h4><p>Runloop设计的比较好的一是加到mode中的所有timer，不是说自己开个port去实现，而是通过Mode中的<code>_timerPort</code>，去触发。</p>
<p>addTimer的时候，CoreFundation会算遍历timers，拿到最近的fire时间，然后通过_timerPort去实现该fire的定时，fire之后会继续计算设置成下一个。</p>
<h5 id="__CFRunLoopTimer_&amp;_CFRunLoopTimerContext">__CFRunLoopTimer &amp; CFRunLoopTimerContext</h5><p>timer的相关结构没什么好说，比较简单</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span>	version;</span><br><span class="line">    <span class="keyword">void</span> *	info;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="built_in">CFStringRef</span>	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">&#125; <span class="built_in">CFRunLoopTimerContext</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoopTimer</span> &#123;</span><br><span class="line">    <span class="built_in">CFRuntimeBase</span> _base;</span><br><span class="line">    uint16_t _bits;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> _runLoop;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _rlModes;</span><br><span class="line">    <span class="built_in">CFAbsoluteTime</span> _nextFireDate;</span><br><span class="line">    <span class="built_in">CFTimeInterval</span> _interval;		<span class="comment">/* immutable */</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> _tolerance;     <span class="comment">//容忍度     /* mutable */</span></span><br><span class="line">    uint64_t _fireTSR;			<span class="comment">/* TSR units */</span></span><br><span class="line">    <span class="built_in">CFIndex</span> _order;			<span class="comment">/* immutable */</span></span><br><span class="line">    <span class="built_in">CFRunLoopTimerCallBack</span> _callout;	<span class="comment">// 回调</span></span><br><span class="line">    <span class="built_in">CFRunLoopTimerContext</span> _context;	<span class="comment">/* immutable, except invalidation */</span></span><br></pre></td></tr></table></figure>
<h4 id="Runloop_observer">Runloop observer</h4><p>Runloop的观察着，顾名思义，runloop的生命周期中的一些切面会被回调回调方法。</p>
<p>看了下代码，回调也是执行在当前Runloop的线程上，所以我觉得如果是在观察主线程的Runloop，最好不要放一些太重的活进去，或者分发到其他线程去。</p>
<h5 id="__CFRunLoopObserver">__CFRunLoopObserver</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoopObserver</span> &#123;</span><br><span class="line">    <span class="built_in">CFRuntimeBase</span> _base; <span class="comment">// 类似OC的isa，不过还存储了observer的isfire，isValid等状态信息</span></span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> _runLoop;</span><br><span class="line">    <span class="built_in">CFIndex</span> _rlCount;</span><br><span class="line">    <span class="built_in">CFOptionFlags</span> _activities;		<span class="comment">// 标识了观测哪些事件</span></span><br><span class="line">    <span class="built_in">CFIndex</span> _order;			<span class="comment">/* immutable */</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverCallBack</span> _callout;	<span class="comment">// 回调</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> _context;	<span class="comment">// 上下文</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span>	version;</span><br><span class="line">    <span class="keyword">void</span> *	info; <span class="comment">// 创建时，传进来的info，回调时会带上</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="built_in">CFStringRef</span>	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">&#125; <span class="built_in">CFRunLoopObserverContext</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Runloop运行函数流程">Runloop运行函数流程</h3><p>Runloop的默认入口是CFRunLoopRun()，此时runloop的mode是DefaultMode。此外还有一个入口是CFRunLoopRunInMode()，可以指定以特定的mode运行。</p>
<p>整个链路是CFRunLoopRun() -&gt; CFRunLoopRunSpecific() -&gt;__CFRunLoopRun(),一个一个来看。</p>
<h3 id="CFRunLoopRun()">CFRunLoopRun()</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="type">CFRunLoopRun</span>(<span class="type">void</span>) &#123;	/* <span class="type">DOES</span> <span class="type">CALLOUT</span> */</span><br><span class="line">    int32_t <span class="literal">result</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="literal">result</span> = <span class="type">CFRunLoopRunSpecific</span>(<span class="type">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1</span>.<span class="number">0</span>e10, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">CHECK_FOR_FORK</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != <span class="literal">result</span> &amp;&amp; kCFRunLoopRunFinished != <span class="literal">result</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到CFRunLoopRun方法就是一个do-while循环，只要运行结果不是stop和finish，就会进入下个循环。逻辑全在<code>CFRunLoopRunSpecific</code>这个方法中.</p>
<h4 id="CFRunLoopRunSpecific()">CFRunLoopRunSpecific()</h4><p>源代码如下，基本上我都加上了注释</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">SInt32 <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="comment">// 如果runloop正在dealloc，则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (__<span class="built_in">CFRunLoopIsDeallocating</span>(rl)) <span class="keyword">return</span> k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    __<span class="built_in">CFRunLoopLock</span>(rl);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得要运行的Mode， 没有则新建新一个Mode，并初始化</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __<span class="built_in">CFRunLoopFindMode</span>(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// __CFRunLoopModeIsEmpty会去检查mode，如果有mode，并且mode至少有timer、observer、source中的任意一个，则为非空，否则退出当次loop</span></span><br><span class="line">    <span class="comment">// 如果当前runloop是主线程上的，条件会简单点，只要存在这个mode name就行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode || __<span class="built_in">CFRunLoopModeIsEmpty</span>(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">	Boolean did = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (currentMode) __<span class="built_in">CFRunLoopModeUnlock</span>(currentMode);</span><br><span class="line">	__<span class="built_in">CFRunLoopUnlock</span>(rl);</span><br><span class="line">	<span class="keyword">return</span> did ? k<span class="built_in">CFRunLoopRunHandledSource</span> : k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成一份新的PerRunData，初始化后，传给runloop</span></span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __<span class="built_in">CFRunLoopPushPerRunData</span>(rl);</span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> previousMode = rl-&gt;_currentMode;</span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    int32_t result = k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知观察者即将进入runloop：kCFRunLoopEntry</span></span><br><span class="line">	<span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopEntry</span> ) __<span class="built_in">CFRunLoopDoObservers</span>(rl, currentMode, k<span class="built_in">CFRunLoopEntry</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调用__CFRunLoopRun，运行runloop，最繁杂逻辑都在里面</span></span><br><span class="line">	result = __<span class="built_in">CFRunLoopRun</span>(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 通知观察者即将退出runloop</span></span><br><span class="line">	<span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopExit</span> ) 		__<span class="built_in">CFRunLoopDoObservers</span>(rl, currentMode, k<span class="built_in">CFRunLoopExit</span>);</span><br><span class="line"></span><br><span class="line">    __<span class="built_in">CFRunLoopModeUnlock</span>(currentMode);</span><br><span class="line">      <span class="comment">// 将Runloop的PerRunData赋值为之前的值，也就是还原成进入之前的状态</span></span><br><span class="line">        __<span class="built_in">CFRunLoopPopPerRunData</span>(rl, previousPerRun);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 当次loop退出后会把mode还原为上一次的mode</span></span><br><span class="line">	rl-&gt;_currentMode = previousMode;</span><br><span class="line">    __<span class="built_in">CFRunLoopUnlock</span>(rl);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最大的逻辑还不在这个方法中，主要做了一些初始化以及上下文的切换，以及进入和退出的通知，Loop的主要逻辑是直接调用了<strong>CFRunLoopRun这个方法，那么接着看 </strong>CFRunLoopRun的实现。</p>
<h4 id="__CFRunLoopRun()">__CFRunLoopRun()</h4><p>为了方便阅读，我把一些只在macOS或者Window上的逻辑都去掉了，并尽可能详细的注释与讲解了每一行代码。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int32_t __<span class="built_in">CFRunLoopRun</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopModeRef</span> rlm, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle, <span class="built_in">CFRunLoopModeRef</span> previousMode) &#123;</span><br><span class="line">	<span class="comment">// 记录当前时钟”嘀嗒”数，可看成该次loop的开始时间</span></span><br><span class="line">    uint64_t startTSR = mach_absolute_time();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *** runloop 是否已结束检测，是则直接退出 --- *** */</span></span><br><span class="line">    <span class="keyword">if</span> (__<span class="built_in">CFRunLoopIsStopped</span>(rl)) &#123;</span><br><span class="line">    <span class="comment">// ↑检查了runloop的_perRunData-&gt;stopped是否为非0</span></span><br><span class="line">        <span class="comment">// runloop 是stop，则将_perRunData-&gt;stopped置为0，并退出当次runloop</span></span><br><span class="line">        __<span class="built_in">CFRunLoopUnsetStopped</span>(rl);</span><br><span class="line">        <span class="keyword">return</span> k<span class="built_in">CFRunLoopRunStopped</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">        <span class="comment">// runloop mode是stop</span></span><br><span class="line">        rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> k<span class="built_in">CFRunLoopRunStopped</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/* *** 这块是主线程下获取dispatchPort的逻辑，如果当前线程不是主线程，就没有什么意义*** */</span></span><br><span class="line">    <span class="comment">// __HAS_DISPATCH__这个宏看代码是 如果部署在Swift的运行时下(DEPLOYMENT_RUNTIME_SWIFT),则是0，否则是1</span></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">    <span class="comment">// 主线程的dispatchPort端口</span></span><br><span class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</span><br><span class="line">    <span class="comment">// pthread_main_np返回当前是否是main thread </span></span><br><span class="line">    <span class="comment">// HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY = 0</span></span><br><span class="line">    <span class="comment">// 总之条件是 当前线程是mainQ才行</span></span><br><span class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVO<span class="built_in">CATION_ONLY</span> &amp;&amp; <span class="literal">NULL</span> == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVO<span class="built_in">CATION_ONLY</span> &amp;&amp; <span class="number">0</span> == _<span class="built_in">CFGetTSD</span>(__<span class="built_in">CFTSDKeyIsInGCDMainQ</span>)));</span><br><span class="line">    <span class="comment">// 如果当前是mainQ，且满足一定条件，获取主线程中的_dispatch_get_main_queue_port_4CF端口</span></span><br><span class="line">    <span class="keyword">if</span> (libdispatchQSafe &amp;&amp; (<span class="built_in">CFRunLoopGetMain</span>() == rl) &amp;&amp; <span class="built_in">CFSetContainsValue</span>(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="comment">/* *** 设置当次loop的超时定时器 *** */</span></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">	<span class="comment">// 定义gcd的定时器</span></span><br><span class="line">    dispatch_source_t timeout_timer = <span class="literal">NULL</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">    <span class="comment">// 时间片检查</span></span><br><span class="line">    <span class="keyword">struct</span> __timeout_context *timeout_context = (<span class="keyword">struct</span> __timeout_context *)malloc(<span class="keyword">sizeof</span>(*timeout_context));</span><br><span class="line">    <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>) &#123; <span class="comment">// instant timeout</span></span><br><span class="line">        <span class="comment">// 剩余时间耗尽</span></span><br><span class="line">        seconds = <span class="number">0.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR = <span class="number">0</span>ULL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">        <span class="comment">// 还有剩余时间</span></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> queue = pthread_main_np() ? __<span class="built_in">CFDispatchQueueGetGenericMatchingMain</span>() : __<span class="built_in">CFDispatchQueueGetGenericBackground</span>();</span><br><span class="line">	timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">        dispatch_retain(timeout_timer);</span><br><span class="line">	timeout_context-&gt;ds = timeout_timer;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">	<span class="comment">// 计算到期的时间点，并赋值</span></span><br><span class="line">	timeout_context-&gt;rl = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFRetain</span>(rl);</span><br><span class="line">	timeout_context-&gt;termTSR = startTSR + __<span class="built_in">CFTimeIntervalToTSR</span>(seconds);</span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">	dispatch_set_context(timeout_timer, timeout_context); <span class="comment">// source gets ownership of context</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 设置timer超时的handler 会把termTSR设为0，并唤醒runloop</span></span><br><span class="line">	dispatch_source_set_event_handler_f(timeout_timer, __<span class="built_in">CFRunLoopTimeout</span>);</span><br><span class="line">    dispatch_source_set_cancel_handler_f(timeout_timer, __<span class="built_in">CFRunLoopTimeoutCancel</span>);</span><br><span class="line">    uint64_t ns_at = (uint64_t)((__<span class="built_in">CFTSRToTimeInterval</span>(startTSR) + seconds) * <span class="number">1000000000</span>ULL);</span><br><span class="line">    dispatch_source_set_timer(timeout_timer, dispatch_time(<span class="number">1</span>, ns_at), DISPATCH_TIME_FOREVER, <span class="number">1000</span>ULL);</span><br><span class="line">    <span class="comment">// 启动定时器</span></span><br><span class="line">    dispatch_resume(timeout_timer);</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// infinite timeout</span></span><br><span class="line">        <span class="comment">// 无限的剩余时间</span></span><br><span class="line">        seconds = <span class="number">9999999999.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR = <span class="built_in">UINT64_MAX</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    Boolean didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">    int32_t retVal = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</span><br><span class="line">        voucher_t voucherCopy = <span class="literal">NULL</span>;</span><br><span class="line">        uint8_t msg_buffer[<span class="number">3</span> * <span class="number">1024</span>];</span><br><span class="line">        mach_msg_header_t *msg = <span class="literal">NULL</span>;</span><br><span class="line">        mach_port_t livePort = MACH_PORT_NULL;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 获得mode上的portset端口， _portSet也是个mach_port_t类型，不过该端口拥有接收消息的功能，能接收自己的menber ports上的消息【1】此处等等会细讲</span></span><br><span class="line">		__<span class="built_in">CFPortSet</span> waitSet = rlm-&gt;_portSet;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获得runloop的perRunData， 设置ignoreWakeUps为0：无视唤醒</span></span><br><span class="line">        __<span class="built_in">CFRunLoopUnsetIgnoreWakeUps</span>(rl);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">/* *** 通知 *** */</span></span><br><span class="line">        <span class="comment">// 通知观察者runloop将处理timer</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopBeforeTimers</span>) __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopBeforeTimers</span>);</span><br><span class="line">        <span class="comment">// 通知观察者runloop将处理Source</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopBeforeSources</span>) __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopBeforeSources</span>);</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">/* *** 触发所有通过CFRunloopPerformBlock方法加入到当前runloop的该mode的所有block *** */</span></span><br><span class="line">        <span class="comment">// 【2】这块等等还会提一下</span></span><br><span class="line">        __<span class="built_in">CFRunLoopDoBlocks</span>(rl, rlm);</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *** 处理Source0上的所有source *** */</span></span><br><span class="line">		<span class="comment">// 通过__CFRunLoopSourceIsSignaled方法获取到Source上的signal标记，只有 signal非0</span></span><br><span class="line">        <span class="comment">// 才会调用所有在该mode上的source0的source的perform函数</span></span><br><span class="line">        	<span class="comment">// 返回值代表了至少有1个source被处理了</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __<span class="built_in">CFRunLoopDoSources0</span>(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            <span class="comment">// source0有处理了触发的source 则重新处理的block</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoBlocks</span>(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记 代表了处理完了source0或者时间没了</span></span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0</span>ULL == timeout_context-&gt;termTSR);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *** 只有在主线程上才有的逻辑，处理dispatchPort上的msg *** */</span></span><br><span class="line"><span class="comment">// 因为非主线，diaptchport是个null</span></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">            <span class="comment">// 如果有主线程的dispatchPort端口上的消息，则处理</span></span><br><span class="line">            		<span class="comment">// 这端口基本就是和GCD中sync/async到主线程相关的端口了</span></span><br><span class="line">            <span class="keyword">if</span> (__<span class="built_in">CFRunLoopServiceMachPort</span>(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            	<span class="comment">// 调到下方的处理msg的逻辑里</span></span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">       didDispatchPortLastTime = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *** 通知 *** */</span></span><br><span class="line">    <span class="comment">// 通知观察者runloop即将睡眠 kCFRunLoopBeforeWaiting</span></span><br><span class="line">	<span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopBeforeWaiting</span>)) __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopBeforeWaiting</span>);</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line">	</span><br><span class="line">      <span class="comment">// runloop标记为睡眠， 通过改变runloop的cfruntimebase的_cfinfo标记</span></span><br><span class="line">	__<span class="built_in">CFRunLoopSetSleeping</span>(rl);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *** 主线程才有用 *** */</span></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">        <span class="comment">// 调用mach_port_insert_member将dispatchport作为waitport的menmber</span></span><br><span class="line">        <span class="comment">// 这样接下去可以通过waitport来接收disptchport的消息以及其他menber的消息</span></span><br><span class="line">        __<span class="built_in">CFPortSetInsert</span>(dispatchPort, waitSet);</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">	__<span class="built_in">CFRunLoopModeUnlock</span>(rlm);</span><br><span class="line">	__<span class="built_in">CFRunLoopUnlock</span>(rl);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 记录睡眠开始的时间</span></span><br><span class="line">        <span class="built_in">CFAbsoluteTime</span> sleepStart = poll ? <span class="number">0.0</span> : <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// timer处理</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k<span class="built_in">CFUseCollectableAllocator</span>) &#123;</span><br><span class="line">            memset(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</span><br><span class="line">        &#125;</span><br><span class="line">        msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">/* *** 进入睡眠，并监听mach端口 *** */</span> </span><br><span class="line">        <span class="comment">// 睡眠，并监听与处理waitport的上的消息，也就是监听所有source1的端口以及之前加上的dispatchport,以及wakeupPort、timerPort</span></span><br><span class="line">        <span class="comment">// 内部调用了mach_msg来接收消息，这块等等还会讲一下【3】</span></span><br><span class="line">        __<span class="built_in">CFRunLoopServiceMachPort</span>(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *** 因为一些原因被唤醒，开始处理唤醒的原因 *** */</span> </span><br><span class="line">        __<span class="built_in">CFRunLoopLock</span>(rl);</span><br><span class="line">        __<span class="built_in">CFRunLoopModeLock</span>(rlm);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 赋值已经睡眠的时间</span></span><br><span class="line">        rl-&gt;_sleepTime += (poll ? <span class="number">0.0</span> : (<span class="built_in">CFAbsoluteTimeGetCurrent</span>() - sleepStart));</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">        __<span class="built_in">CFPortSetRemove</span>(dispatchPort, waitSet);</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">        __<span class="built_in">CFRunLoopSetIgnoreWakeUps</span>(rl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置非睡眠状态</span></span><br><span class="line">	__<span class="built_in">CFRunLoopUnsetSleeping</span>(rl);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* *** 通知 *** */</span></span><br><span class="line">        <span class="comment">// 通知观察者runloop睡眠结束 kCFRunLoopAfterWaiting</span></span><br><span class="line">	<span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopAfterWaiting</span>)) __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopAfterWaiting</span>);</span><br><span class="line">	<span class="comment">/* *** end *** */</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 开始处理消息</span></span><br><span class="line">        handle_msg:;</span><br><span class="line">        <span class="comment">// 设置无视睡眠</span></span><br><span class="line">        __<span class="built_in">CFRunLoopSetIgnoreWakeUps</span>(rl);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理唤醒的原因</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL == livePort) &#123;</span><br><span class="line">            <span class="comment">// 没有被任意的machport端口唤醒</span></span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_NOTHING</span>();</span><br><span class="line">            <span class="comment">// handle nothing</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">        	<span class="comment">// 被wakeupport端口唤醒， 上层上一般是通过CFRunLoopWakeUp产生的唤醒</span></span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_WAKEUP</span>();</span><br><span class="line">            <span class="comment">// do nothing on Mac OS</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* *** 处理Timer *** */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">        	<span class="comment">// 由于mode的timerport fire了被唤醒</span></span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_TIMER</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理Model上的所有timers</span></span><br><span class="line">            <span class="keyword">if</span> (!__<span class="built_in">CFRunLoopDoTimers</span>(rl, rlm, mach_absolute_time())) 			&#123;</span><br><span class="line">                <span class="comment">// 重新设置timer下一个触发的时间</span></span><br><span class="line">                __<span class="built_in">CFArmNextTimerInMode</span>(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* *** end *** */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* *** 如果当前是主线程，处理GCD dispatch到主线程上的block *** */</span></span><br><span class="line">		<span class="comment">// 因为如果不是主线程 dispatchPort就不会被赋值，也就走上面的逻辑了</span></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">        	<span class="comment">// 当前是主线程， 且有block dispatch到主线程上</span></span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_DISPATCH</span>();</span><br><span class="line">            __<span class="built_in">CFRunLoopModeUnlock</span>(rlm);</span><br><span class="line">            __<span class="built_in">CFRunLoopUnlock</span>(rl);</span><br><span class="line">            _<span class="built_in">CFSetTSD</span>(__<span class="built_in">CFTSDKeyIsInGCDMainQ</span>, (<span class="keyword">void</span> *)<span class="number">6</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 处理主线程的block</span></span><br><span class="line">            __<span class="built_in">CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span>(msg);</span><br><span class="line">            _<span class="built_in">CFSetTSD</span>(__<span class="built_in">CFTSDKeyIsInGCDMainQ</span>, (<span class="keyword">void</span> *)<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            __<span class="built_in">CFRunLoopLock</span>(rl);</span><br><span class="line">            __<span class="built_in">CFRunLoopModeLock</span>(rlm);</span><br><span class="line">            sourceHandledThisLoop = <span class="literal">true</span>;</span><br><span class="line">            didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">		<span class="comment">/* *** end *** */</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* *** 处理source1上的消息 *** */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_SOURCE</span>();</span><br><span class="line">            <span class="comment">// Despite the name, this works for windows handles as well</span></span><br><span class="line">            <span class="comment">// 找到具体的source1里的source</span></span><br><span class="line">            <span class="built_in">CFRunLoopSourceRef</span> rls = __<span class="built_in">CFRunLoopModeFindSourceForMachPort</span>(rl, rlm, livePort);</span><br><span class="line">            <span class="keyword">if</span> (rls) &#123;</span><br><span class="line">		mach_msg_header_t *reply = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">// 处理Source1的消息</span></span><br><span class="line">                <span class="comment">// __CFRunLoopDoSource1会调用__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__，进而调用source1上的perform函数</span></span><br><span class="line">		sourceHandledThisLoop = __<span class="built_in">CFRunLoopDoSource1</span>(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">		<span class="comment">// 具体的perform函数的返回值reply msg非空</span></span><br><span class="line">		<span class="comment">// 把reply消息发送回消息的来源，告知消息处理完了</span></span><br><span class="line">		    (<span class="keyword">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">		    <span class="built_in">CFAllocatorDeallocate</span>(k<span class="built_in">CFAllocatorSystemDefault</span>, reply);</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) 			free(msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* *** 处理通过CFRunLoopPerformBlock 加入的block *** */</span></span><br><span class="line">		__<span class="built_in">CFRunLoopDoBlocks</span>(rl, rlm);</span><br><span class="line">		<span class="comment">/* *** end *** */</span></span><br><span class="line"><span class="comment">/* *** end *** */</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* *** 处理当次loop的结果 非0则退出loop *** */</span></span><br><span class="line">	<span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">        <span class="comment">// 处理完了source 处理了source并且上层传入的入参决定调用后需要停止</span></span><br><span class="line">	    retVal = k<span class="built_in">CFRunLoopRunHandledSource</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            <span class="comment">// 时间片到了</span></span><br><span class="line">            retVal = k<span class="built_in">CFRunLoopRunTimedOut</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__<span class="built_in">CFRunLoopIsStopped</span>(rl)) &#123;</span><br><span class="line">        <span class="comment">// runloop停止了</span></span><br><span class="line">            __<span class="built_in">CFRunLoopUnsetStopped</span>(rl);</span><br><span class="line">	    retVal = k<span class="built_in">CFRunLoopRunStopped</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">        <span class="comment">// mode被停止了</span></span><br><span class="line">	    rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">	    retVal = k<span class="built_in">CFRunLoopRunStopped</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__<span class="built_in">CFRunLoopModeIsEmpty</span>(rl, rlm, previousMode)) &#123;</span><br><span class="line">        <span class="comment">// 没有mode了，直接finish loop</span></span><br><span class="line">	    retVal = k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    <span class="comment">/* *** end *** */</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if __HAS_DISPATCH__</span></span><br><span class="line">    <span class="keyword">if</span> (timeout_timer) &#123;</span><br><span class="line">        <span class="comment">// 取消超时的定时器</span></span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">    &#123;</span><br><span class="line">        free(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#####【1】关于portSet<br>一个thread中最多只能有一个拥有接收权限的portSet，(拥有接收权限的port可以很多)，虽然porSet也是个mach_port_t，不过它可以包含很多个machport作为他的member，这一整个集合就会表现的像一个port一样。如果是通过portSet去接收mach msg，他会从任意一个接收到了消息的member的消息队列中取出消息。</p>
<p>每个Mode初始化创建的时候，timer port、source port，waitPort都会加到这个portSet中。</p>
<p>#####【2】关于__CFRunLoopDoBlocks()与CFRunloopPerformBlock()<br>CoreFundation提供了CFRunloopPerformBlock()这个方法，能将一个block显示的放到特定的Runloop的特定的Mode上的block链表中，等待执行。</p>
<p>和gcd的区别在于，gcd是直接将block放到common mode上，而前者可指定mode，以及gcd的会主动wake up runloop(主线程甚至有专门处理的gcd的port)，而CFRunloopPerformBlock()并不会wake up runloop，如果你不手动wake up，那么这个block只能等其他事件把runloop唤醒了，在__CFRunLoopDoBlocks()函数中被处理。</p>
<p>#####【3】关于__CFRunLoopServiceMachPort()函数</p>
<p>__CFRunLoopServiceMachPort里面有个for循环，通过调用了用户态的mach_msg()函数，而后者会通过内核的Mach陷阱机制调用mach_msg_trap()，然后mach_msg_trap()会调用mach_msg_overwrite_trap(),mach_msg_overwrite_trap()通过入参的标识，来判断是发送消息还是接收消息，从而进行IPC。</p>
<p>另外__CFRunLoopServiceMachPort在mach_msg()前还会调用CFRUNLOOP_SLEEP()，之后调CFRUNLOOP_WAKEUP()，不过是闭源的。</p>
<p>#####【4】防止尾递归优化<br>Runloop中很多方法由于内部逻辑场景很可能会被编译器尾递归优化，比如<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong>、<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong>等函数，但苹果在这些函数内部最后都加了条</p>
<pre><code><span class="function">asm <span class="title">__volatile__</span><span class="params">(<span class="string">""</span>)</span></span>;
</code></pre><p>来防止尾递归优化，可能出于debug考虑，这个几个函数调用的栈帧对debug挺重要的。</p>
<h5 id="【5】In_that_sleep_of_death_what_nightmares_may_come">【5】In that sleep of death what nightmares may come</h5><p>在【3】中的__CFRunLoopServiceMachPort函数中，在调用mach_msg()的for之前苹果注释了句话:</p>
<p><strong><em> //In that sleep of death what nightmares may come</em></strong></p>
<p>估计是出自《哈姆雷特》第三章，原文：</p>
<p><strong><em>For in that sleep of death what dreams may come</em></strong></p>
<p>然后把dreams改为了nightmares，苹果工程师真是因缺思厅 : )</p>
<h3 id="结尾">结尾</h3><p>语言不管怎么变，设计和思想是永远能借用的，RunLoop设计非常值得借鉴与思考，未来有空看看安卓的Looper的源码。</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Core-Fundation/" rel="tag">#Core Fundation</a>
          
            <a href="/tags/RunLoop/" rel="tag">#RunLoop</a>
          
            <a href="/tags/iOS/" rel="tag">#iOS</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/06/22/OSX_task_for_pid()_FAILURE/" rel="next" title="OSX ElCapitan之后task_for_pid() MACH陷阱调用结果KERN_FAILURE原因与解决方案">
                <i class="fa fa-chevron-left"></i> OSX ElCapitan之后task_for_pid() MACH陷阱调用结果KERN_FAILURE原因与解决方案
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/11/02/objc_msgsend/" rel="prev" title="Objective-C Runtime汇编源码解析之objc_msgSend(arm64版本)">
                Objective-C Runtime汇编源码解析之objc_msgSend(arm64版本) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/07/04/Runloop/"
     data-title="CoreFundation源码解析之RunLoop"
     data-content=""
     data-url="http://blog.SatoshiChin.com/2016/07/04/Runloop/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


        </div>

        


        
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/07/04/Runloop/"
           data-title="CoreFundation源码解析之RunLoop" data-url="http://blog.SatoshiChin.com/2016/07/04/Runloop/">
      </div>
    
  </div>


      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/uploads/avatar.png" alt="SatoshiChin" itemprop="image"/>
          <p class="site-author-name" itemprop="name">SatoshiChin</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Think different</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://www.weibo.com/u/2840829854" target="_blank">
                  
                    <i class="fa fa-globe"></i> weibo
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#CoreFundation源码解析之RunLoop"><span class="nav-number">1.</span> <span class="nav-text">CoreFundation源码解析之RunLoop</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是RunLoop"><span class="nav-number">1.1.</span> <span class="nav-text">什么是RunLoop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构定义"><span class="nav-number">1.2.</span> <span class="nav-text">数据结构定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CFRunloop"><span class="nav-number">1.2.1.</span> <span class="nav-text">CFRunloop</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runloop_Mode"><span class="nav-number">1.3.</span> <span class="nav-text">Runloop Mode</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Runloop_Mode的数据结构"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">Runloop Mode的数据结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runloop_Source"><span class="nav-number">1.3.1.</span> <span class="nav-text">Runloop Source</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runloop_Source数据结构"><span class="nav-number">1.3.2.</span> <span class="nav-text">Runloop Source数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CFRunLoopSourceContext"><span class="nav-number">1.3.3.</span> <span class="nav-text">CFRunLoopSourceContext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CFRunLoopSourceContext1"><span class="nav-number">1.3.4.</span> <span class="nav-text">CFRunLoopSourceContext1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runloop_Timer"><span class="nav-number">1.3.5.</span> <span class="nav-text">Runloop Timer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#__CFRunLoopTimer_&_CFRunLoopTimerContext"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">__CFRunLoopTimer & CFRunLoopTimerContext</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runloop_observer"><span class="nav-number">1.3.6.</span> <span class="nav-text">Runloop observer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#__CFRunLoopObserver"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">__CFRunLoopObserver</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runloop运行函数流程"><span class="nav-number">1.4.</span> <span class="nav-text">Runloop运行函数流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopRun()"><span class="nav-number">1.5.</span> <span class="nav-text">CFRunLoopRun()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CFRunLoopRunSpecific()"><span class="nav-number">1.5.1.</span> <span class="nav-text">CFRunLoopRunSpecific()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#__CFRunLoopRun()"><span class="nav-number">1.5.2.</span> <span class="nav-text">__CFRunLoopRun()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#【5】In_that_sleep_of_death_what_nightmares_may_come"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">【5】In that sleep of death what nightmares may come</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结尾"><span class="nav-number">1.6.</span> <span class="nav-text">结尾</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SatoshiChin</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"satoshichin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.2" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    motionMiddleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');
      if (CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    };
  });
</script>



  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
